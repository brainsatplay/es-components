{
  "version": 3,
  "sources": ["../../../packages/common/check.js", "../../../packages/esmonitor/src/utils.ts", "../../../packages/esmonitor/src/Poller.ts", "../../../packages/esmonitor/src/listeners.ts", "../../../packages/esmonitor/src/global.ts", "../../../packages/esmonitor/src/info.ts", "../../../packages/esmonitor/src/globals.ts", "../../../spec/standards.js", "../../../packages/common/pathHelpers.ts", "../../../packages/esmonitor/src/inspectable/handlers.ts", "../../../packages/esmonitor/src/inspectable/define.ts", "../../../packages/common/globals.ts", "../../../packages/esmonitor/src/inspectable/index.ts", "../../../packages/esmonitor/src/optionsHelpers.ts", "../../../packages/common/drill.js", "../../../packages/esmonitor/src/Monitor.ts", "../../../packages/esmonitor/src/index.ts", "../../../packages/common/properties.ts", "../../../packages/common/clone.js", "../../../packages/common/utils/index.ts", "../../../packages/escode-compose-loader/compile/wasm.ts", "../../../packages/escode-compose-loader/compile/index.ts", "../../../packages/escode-compose-loader/index.ts", "../../../packages/core/symbols.ts", "../../../packages/core/parse.ts", "../../../packages/core/globals.ts", "../../../packages/core/edgelord/index.ts", "../../../packages/core/components.ts", "../../../packages/core/loaders/props/index.ts", "../../../packages/core/loaders/parent/index.ts", "../../../packages/core/loaders/parent/path/index.ts", "../../../packages/core/load.ts", "../../../packages/core/index.ts", "../../../demos/graph/nodes/nodeA.js", "../../../demos/utils.ts", "../../../demos/graph/tree.js", "../../../packages/escode-animate-loader/index.ts", "../../../demos/graph/index.ts", "../../../packages/common/benchmark.ts", "../../../demos/graph/benchmark.ts"],
  "sourcesContent": ["const moduleStringTag = '[object Module]'\n\nexport const esm = (object) => {\n    const res = object && (!!Object.keys(object).reduce((a,b) => {\n        const desc = Object.getOwnPropertyDescriptor(object, b)\n        const isModule = (desc && desc.get && !desc.set) ? 1 : 0\n        return a + isModule\n    }, 0) || Object.prototype.toString.call(object) === moduleStringTag)\n\n    return !!res\n}", "import { Options } from \"../../common/types\"\nimport { ArrayPath, MonitorOptions } from \"./types\"\n\n\nexport const isSame = (a,b) => {\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        const jA = JSON.stringify(a)\n        const jB = JSON.stringify(b)\n        return jA === jB\n    } else return a === b\n}\n\n\nexport const iterateSymbols = (obj, callback) => {\n    return Promise.all(Object.getOwnPropertySymbols(obj).map((sym: symbol) => callback(sym, obj[sym])))\n}\n\nexport const  getPath = (type, info) => {\n    const pathType = info.path[type]\n    if (!pathType) throw new Error('Invalid Path Type')\n    const filtered = pathType.filter((v) => typeof v === 'string')\n    return filtered.join(info.keySeparator)\n}\n\nexport const getPathInfo = (path, options: MonitorOptions) => {\n    let splitPath = path\n    if (typeof path === 'string') splitPath = path.split(options.keySeparator)\n    else if (typeof path === 'symbol') splitPath = [path]\n    return {\n        id: splitPath[0],\n        path: splitPath.slice(1) as ArrayPath,\n    }\n}\n\nexport const runCallback = (callback, path, info, output, setGlobal=true) => {\n    if (callback instanceof Function) {\n        \n        // Promises\n        if (output && typeof output === 'object' && typeof output.then === 'function') output.then(value => callback(path, info, value))\n\n        // Normal\n        else callback(path, info, output)\n    }\n\n    // ------------------ Set Manually in Inspected State ------------------\n    if (setGlobal && globalThis.ESMonitorState) {\n        const callback = globalThis.ESMonitorState.callback\n        globalThis.ESMonitorState.state[path] = { output, value: info }\n        runCallback(callback, path, info, output, false)\n    }\n}", "import * as utils from './utils'\nimport { ListenerInfo, PollingOptions, ReferenceShortcut } from './types'\n\nconst defaultSamplingRate = 60\n\nexport default class Poller {\n\n    #pollingId?: NodeJS.Timer;\n    #sps: number;\n\n    listeners: {[x:symbol]: ListenerInfo} = {}\n\n    get sps(){\n        return this.#sps\n    }\n\n    set sps(sps: number) {\n        this.#sps = sps\n\n        const listeners = this.listeners\n        const nListeners = Object.keys(listeners).length\n        if (nListeners){\n            this.stop()\n            this.start()\n        }\n    }\n\n    constructor(\n        listeners?: Poller['listeners'],\n        sps?: Poller['sps']\n    ) {\n        if (listeners) this.listeners = listeners // Initialize listeners externally\n        if (sps) this.sps = sps // Set sampling rate externally\n    }\n\n    setOptions = (opts: PollingOptions = {}) => {\n        for (let key in opts) this[key] = opts[key] // Merge polling option\n    }\n\n\n    // Basic Object Manipulation\n    add = (info: ListenerInfo) => {\n        const sub = info.sub\n        this.listeners[sub] = info\n        this.start() // Start polling if not already started\n        return true\n    }\n    get = (sub: ListenerInfo['sub']) => this.listeners[sub]\n    remove = (sub: ListenerInfo['sub']) => {\n        delete this.listeners[sub]\n        if (!Object.keys(this.listeners).length) this.stop() // Stop polling if no listeners\n    }\n\n    // Poll Listeners\n    poll = (listeners) => {\n        utils.iterateSymbols(listeners, (sym, o) => {\n            let { callback, current, history } = o\n\n            // Resolving the path once\n            if (!o.path.resolved) o.path.resolved = utils.getPath('output', o)\n\n            if (!utils.isSame(current, history)){\n                utils.runCallback(callback, o.path.resolved, {}, current)\n                if (typeof current === 'object') {\n                    if (Array.isArray(current)) history = [...current]\n                    else history = {...current}\n                } else listeners[sym].history = current\n            }\n        })\n    }\n\n    // Start Polling\n    start = (listeners = this.listeners) => {\n        if (!this.sps) this.sps = defaultSamplingRate // Set default sampling rate\n        else if (!this.#pollingId) {\n            console.warn('[esmonitor]: Starting Polling!')\n            this.#pollingId = setInterval(() => this.poll(listeners), 1000/this.sps)\n        }\n    }\n\n    // Stop Polling\n    stop = () => {\n        if (this.#pollingId) {\n            console.warn('[esmonitor]: Stopped Polling!')\n            clearInterval(this.#pollingId)\n            this.#pollingId = undefined\n        }\n    }\n}\n", "import { ArrayPath, ListenerInfo, ListenerLookups, ListenerPool, ListenerRegistry, MonitorOptions, ReferenceShortcut } from \"./types\"\nimport * as utils from './utils'\nimport * as infoUtils from './info'\nimport { isProxy } from './globals'\nimport { getFromPath } from \"../../common/pathHelpers\"\nimport { setFromOptions } from \"./optionsHelpers\"\n\nexport const info = (id, callback, path, originalValue, base, listeners, options: MonitorOptions, refShortcut: Partial<ReferenceShortcut> = {}) => {\n    if (typeof path === 'string') path = path.split(options.keySeparator)\n    const relativePath = path.join(options.keySeparator)\n\n    const refs = base\n\n    const shortcutRef = refShortcut.ref\n    const shortcutPath = refShortcut.path\n\n    const get = (path: ArrayPath) => {\n        const thisBase = shortcutRef ?? base\n \n        const res = getFromPath(thisBase, path, {\n            keySeparator: options.keySeparator,\n            fallbacks: options.fallbacks,\n        })\n\n        return res\n    }\n\n    const set = (path: ArrayPath, value) => {\n        const thisBase = shortcutRef ?? base\n\n        setFromOptions(path, value, options, {\n            reference: thisBase,\n            listeners\n        })\n    }\n\n    // Derive onUpdate Function\n    let onUpdate = options.onUpdate\n    let infoToOutput = {}\n\n    if (onUpdate && typeof onUpdate === 'object' && onUpdate.callback instanceof Function) {\n        infoToOutput = onUpdate.info ?? {}\n        onUpdate = onUpdate.callback\n    }\n\n    const absolute = [id, ...path]\n    let pathInfo = {\n        absolute,\n        relative: relativePath.split(options.keySeparator),\n        parent: absolute.slice(0,-1)\n    } as Partial<ListenerInfo['path']>\n\n    pathInfo.output =  pathInfo[options.pathFormat]\n    const completePathInfo = pathInfo as ListenerInfo['path']\n\n    const info = {\n        id, \n        path: completePathInfo, \n        keySeparator: options.keySeparator,\n\n        infoToOutput,\n        callback: (...args) => {\n            const output = callback(...args)\n            \n            // ------------------ Run onUpdate Callback ------------------\n            if (onUpdate instanceof Function) onUpdate(...args)\n\n            // Return Standard Output\n            return output\n        }, \n        get current() { return get(shortcutPath ?? info.path.absolute) },\n        set current(val) { set(shortcutPath ?? info.path.absolute, val) },\n        get parent() { \n            return get(shortcutPath ? shortcutPath?.slice(0,-1) : info.path.parent) \n        },\n        get reference(){ return refs[id] },\n        set reference(val){ refs[id] = val },\n        original: originalValue,\n        history: (typeof originalValue === 'object') ? Object.assign({}, originalValue) : originalValue,\n        sub: Symbol('subscription'),\n        last: path.slice(-1)[0],\n    } as ListenerInfo\n\n    return info\n}\n\n\nconst registerInLookup = (name, sub, lookups) => {\n\n    if (lookups) {\n        const id = Math.random()\n        lookups.symbol[sub] = {\n            name,\n            id \n        } // set in lookup\n        if (!lookups.name[name]) lookups.name[name] = {}\n        lookups.name[name][id] = sub\n    }\n}\n\nexport const register = (info, collection, lookups?: ListenerLookups) => {\n    // Place in Function Registry\n    const absolute = utils.getPath('absolute', info)\n    if (!collection[absolute]) collection[absolute] = {}\n    collection[absolute][info.sub] = info\n\n    // Place in Lookup Registry\n    registerInLookup(absolute, info.sub, lookups)\n    return true\n}\n\nconst listeners = {\n    functions, \n    setters\n}\n\n// Set Listener with Minimal Information\nexport const set = (type, absPath, value, callback, base, allListeners: Partial<ListenerRegistry>, options: MonitorOptions) => {\n\n    const { id, path } = utils.getPathInfo(absPath, options)\n\n    const fullInfo = info(id, callback, path, value, base, listeners, options)\n\n    // ------------------ Set Listener in Registry ------------------\n    if (listeners[type]) listeners[type](fullInfo, allListeners, allListeners.lookup) // goes up to register()\n    else {\n        const path = utils.getPath('absolute', fullInfo)\n        allListeners[type][path][fullInfo.sub] = fullInfo\n        if (allListeners.lookup) registerInLookup(path, fullInfo.sub, allListeners.lookup)\n    }\n}\n\nconst get = (info, collection) => collection[utils.getPath('absolute', info)]\n\n\nconst handler = (info, collection, subscribeCallback, lookups?: ListenerLookups) => {\n    \n    // Create Listener for this Object\n    let success = !!get(info, collection)\n    if (!success) {\n        let parent = info.parent\n        let val = parent?.[info.last] // Parent may not exist yet...but we still want to register a potential listener\n        success = subscribeCallback(val, parent)\n    }\n\n    // Register in Collection\n    // if (success) \n    return register(info, collection, lookups)\n    // else console.warn('Listener revoked for non-existent parent:', info.path.absolute ) \n}\n\n\nexport const setterExecution = (listeners, value) => {\n    return utils.iterateSymbols(listeners, (_, o: ListenerInfo) => {\n        const path = utils.getPath('output', o)\n        utils.runCallback(o.callback, path,  {}, value)\n    })\n}\n\nexport function setters (info: ListenerInfo, collection: ListenerPool, lookups?: ListenerLookups) {\n\n    const thisValue = this \n    return handler(info, collection['setters'], (value, parent) => {\n\n        let val = value\n        if (!parent) return\n\n        if (!parent[isProxy]) { \n\n            let redefine = true\n            try {\n                delete parent[info.last] // removing original definition\n            }  catch (e) {\n                console.error('Unable to redeclare setters. May already be a dynamic object...')\n                redefine  = false\n            }\n\n            if (redefine) {\n                const isGraphScriptProperty = info.last.slice(0,2) === '__' || info.last === 'default'\n                try {\n                    Object.defineProperty(parent, info.last, {\n                        get: () => val,\n                        set: async (v) => {\n                            const isFunction = typeof val === 'function'\n                            val = v\n                            if (!isFunction) {\n                                const listeners = Object.assign({}, collection['setters'][utils.getPath('absolute', info)])\n                                setterExecution(listeners, v)\n                            }\n                            else val = getProxyFunction.call(thisValue, info, collection, val)\n                        },\n                        enumerable: !isGraphScriptProperty,\n                        configurable: true // TODO: Ensure that you are removing later...\n                    })\n                } catch (e) {\n                    throw e\n                }\n            }\n        }\n    }, lookups)\n}\n\n\nexport function getProxyFunction(info, collection, fn) {\n    return function (...args) {\n        const listeners = collection['functions'][utils.getPath('absolute', info)]\n        const res = functionExecution(this, listeners, fn ?? info.original, args)\n        return res.output // Return Standard Output\n    }\n}\n\nexport const functionExecution = (context, listeners, func, args) => {\n    listeners = Object.assign({}, listeners)\n    const keys = Object.getOwnPropertySymbols(listeners)\n    const infoTemplate = listeners[keys[0]] ?? {} as ListenerInfo // Info is same, callback is different\n    const executionInfo = infoUtils.get((...args) => func.call(context, ...args), args, infoTemplate.infoToOutput)\n\n    utils.iterateSymbols(listeners, (_, o: ListenerInfo) => {\n        const path = utils.getPath('output', o)\n        utils.runCallback(o.callback, path, executionInfo.value, executionInfo.output)\n    })\n\n    return executionInfo\n}\n\n\nexport function functions (info: ListenerInfo, collection: ListenerPool, lookups?: ListenerLookups) {\n\n    // Register for functions\n    return handler(info, collection['functions'], (_, parent) => {      \n        if (!parent[isProxy]) { \n            parent[info.last] = getProxyFunction.call(this, info, collection)\n\n            // Also register as a setter\n            return setters(info, collection, lookups)\n        }\n    }, lookups)\n}", "import { Info } from \"./types\";\n\ntype GlobalESMonitorState = {\n    state: {[x:string]: {output: any, value: any}},\n    callback?: Function | undefined,\n    info: Info\n}\n\ndeclare global {\n    interface Window { ESMonitorState: GlobalESMonitorState; }\n}\n\n// ------------- Global Inspectable (monitored for all changes) -------------\nglobalThis.ESMonitorState = {\n    state: {},\n    callback: undefined,\n    info: {}\n} as GlobalESMonitorState\n\n\nexport default globalThis.ESMonitorState", "import global from './global'\nimport { ActiveInfo } from './types'\n\nexport const performance = async (callback, args) => {\n    \n    const tic = globalThis.performance.now()\n    const output = await callback(...args)\n    const toc = globalThis.performance.now()\n    \n    return {\n        output,\n        value: toc - tic\n    }\n}\n\nconst infoFunctions = {\n    performance\n}\n\nexport const get = (func, args, info) => {\n\n    let result = {\n        value: { },\n        output: undefined,\n    } as {\n        value: ActiveInfo,\n        output: any\n    }\n    \n    \n    const infoToGet = {...global.info, ...info}\n\n    for (let key in infoToGet)  {\n        if (infoToGet[key] && infoFunctions[key]) {\n            const ogFunc = func\n            func = async (...args) => {\n                const o = await infoFunctions[key](ogFunc, args)\n                result.value[key] = o.value\n                return o.output\n            }   \n        }\n    }\n\n    result.output = func(...args)\n    return result\n}", "export const isProxy = Symbol(\"isProxy\")\n\nexport const fromInspectable = Symbol(\"fromInspectable\")\n\nexport const fromInspectableHandler = Symbol(\"fromInspectableHandler\")", "export const keySeparator = '.'\n\nexport const defaultPath = 'default'\n\nexport const esSourceKey = '__esmpileSourceBundle'\n\n\nexport const defaultProperties = {\n    isGraphScript: '__', // Includes path\n    properties: '__props',\n\n    default: defaultPath,\n    parent: '__parent',\n    promise: '__childresolved',\n\n    component: '__component',\n    proxy: '__proxy' // Handled by ESMonitor for Listeners\n}\n\nexport const specialKeys = {\n\n   ...defaultProperties,\n\n    start: '__onconnected', // asked to start\n    stop: '__ondisconnected',\n    connected: '__connected', // wait until connected\n    resolved: '__resolved', // wait until fully resolved\n    started: '__started', // wait until started\n\n    element: '__element',\n    webcomponents: '__define',\n    attributes: '__attributes',\n\n    listeners: {\n        value: '__listeners',\n        branch: '__branch',\n        bind: '__bind',\n        trigger: '__trigger',\n        format: '__format',\n    },\n\n    trigger: '__trigger',\n    compose: '__compose',\n    apply: '__apply',\n\n    // Internal to Compose\n    uri: 'src',\n    reference: 'ref',\n\n    childPosition: '__childposition',\n\n    attribute: 'escomponent',\n    options: '__options',\n\n    source: '__source',\n    path: '__path',\n\n    animate: '__animate',\n    states: '__states',\n\n    editor: '__editor',\n\n    original: '__original',\n\n    resize: '__onresize',    \n}", "import { PathFormat, SetValueOptions } from \"../esmonitor/src/types\"\nimport * as standards from '../../spec/standards'\nimport { deep } from \"./clone\"\n\nconst hasKey = (key, obj) =>  key in obj\n\n\nconst getShortcut = (path, shortcuts, keySeparator) => {\n    const sc = shortcuts[path[0]]\n    if (sc) {\n        const value = sc[path.slice(1).join(keySeparator)]\n        if (value) return value\n    }\n}\n\nexport const getFromPath = (baseObject, path, opts: any = {}) => {\n\n\n    const fallbackKeys = opts.fallbacks ?? []\n    const keySeparator = opts.keySeparator ?? standards.keySeparator\n\n    if (opts.shortcuts) {\n        const shortcut = getShortcut(path, opts.shortcuts, keySeparator)\n        if (shortcut) {\n            if (opts.output === 'info') return { value: shortcut, exists: true, shortcut: true }\n            else return shortcut\n        }\n    }\n\n\n    if (typeof path === 'string') path = path.split(keySeparator).flat()\n    else if (typeof path == 'symbol') path = [path]\n\n    let exists;\n    path = [...path]\n\n    path = path.map(o => (typeof o === \"string\") ? o.split(keySeparator) : o).flat()\n\n\n    let ref =  baseObject\n    const chain = [ref]\n    \n    for (let i = 0; i < path.length; i++) {\n\n        if (ref) {\n\n            const str = path[i]\n            \n            // Try Standard Path\n            exists = hasKey(str, ref)\n\n            if (exists) ref = ref[str]\n            else {\n                ref = undefined\n                exists = true\n            }\n\n            chain.push(ref)\n        }\n    }\n\n    if (opts.output === 'info') return { value: ref, exists,  parent: chain[chain.length - 2] }\n    else return ref\n}\n\n\nexport const setFromPath = (path: PathFormat, value: any, ref:any, opts: SetValueOptions = {}) => {\n    const create = opts?.create ?? false\n    const keySeparator = opts?.keySeparator ?? standards.keySeparator\n\n    if (typeof path === 'string') path = path.split(keySeparator)\n    else if (typeof path == 'symbol') path = [path]\n    path = [...path]\n\n    const copy = [...path]\n    const last = copy.pop() as string | symbol\n\n    for (let i = 0; i < copy.length; i++) {\n        const str = copy[i]  \n        let has = hasKey(str, ref)\n        \n        // Create if not found\n        if (create && !has) {\n            ref[str] = {}\n            has = true\n        }\n\n        // Swap reference\n        if (has) ref = ref[str]\n    }\n\n    ref[last] = value\n\n    return true\n}", "import * as listenerUtils from \"../listeners\";\nimport { runCallback } from \"../utils\";\nimport { \n    fromInspectable,\n    isProxy \n} from '../globals'\nimport Inspectable from \".\";\nimport define from \"./define\";\n\nexport const functions = function () {\n    const inspectable = this as Inspectable\n    return {\n        apply: async function (target, thisArg, argumentsList) {\n            try {\n\n                let foo = target\n                const isFromInspectable = argumentsList[0]?.[fromInspectable] \n                if (isFromInspectable) {\n                    foo = argumentsList[0].value\n                    argumentsList = argumentsList.slice(1)\n                }\n\n\n\n                let listeners = inspectable.listeners.functions\n                // Notify of Function Execution\n                const pathStr = inspectable.path.join(inspectable.options.keySeparator)\n\n                const toActivate =  (listeners) ? listeners[pathStr] : undefined\n                let output, executionInfo: any = {};\n\n                if (toActivate){\n                    executionInfo = listenerUtils.functionExecution(thisArg, toActivate, foo, argumentsList)\n                    output = executionInfo.output\n                } \n                \n                // Default Behavior\n                else {\n                    output = foo.apply(thisArg, argumentsList);\n                    executionInfo = inspectable?.state?.[pathStr]?.value ?? {}\n                }\n\n                \n                // Notify with Proxy Callback\n                const callback = inspectable.options.callback\n\n                runCallback(callback, pathStr, executionInfo, output)\n\n                // Return output to function\n                return output\n\n            } catch (e) {\n                console.warn(`Function failed:`, e, inspectable.path);\n            }\n        }\n    };\n}\n\nexport const objects = function () {\n    const inspectable = this as Inspectable\n    return {\n\n        get (target, prop, receiver) {\n            if (prop === isProxy) return true;\n            return Reflect.get(target, prop, receiver);\n        },\n        \n        set(target, prop, newVal, receiver) {   \n                        \n\n            if (prop === isProxy) return true;\n\n            const pathStr = [...inspectable.path, prop].join(inspectable.options.keySeparator)\n\n            const isFromProxy = newVal?.[isProxy]\n            const isFromInspectable = newVal?.[fromInspectable]\n            if (isFromInspectable) newVal = newVal.value\n\n            const listeners = inspectable.listeners.setters \n\n            // Set New Listeners Automatically (if global callback is specified)\n            const desc = Object.getOwnPropertyDescriptor(target, prop)\n            const createListener = desc && !desc.get && !desc.set\n\n            if (createListener) {\n                if (typeof inspectable.options.globalCallback === 'function') {\n                    const id = inspectable.path[0]\n                    define.call(inspectable, prop, true) // Get notified when changed on the target\n                    listenerUtils.set('setters', pathStr, newVal, inspectable.options.globalCallback, {[id]: inspectable.root}, inspectable.listeners, inspectable.options)\n                }\n            }\n\n\n            // Create Proxies for Objects\n            if (newVal || typeof newVal === 'function') {\n                const newProxy = inspectable.create(prop, target, newVal)\n                if (newProxy) newVal = newProxy\n            }\n\n            const toActivate = !isFromProxy\n            if (\n                listeners \n                && toActivate // Don't manually trigger for proxies\n                && !inspectable.newKeys.has(prop) // Don't manually trigger for new keys\n            ) {\n                const toActivate = listeners[pathStr]\n                if (toActivate) listenerUtils.setterExecution(toActivate, newVal) // run callbacks\n            }\n\n            const callback = inspectable.options.callback\n            const info = inspectable?.state?.[pathStr]?.value ?? {}\n            runCallback(callback, pathStr, info, newVal)\n\n            if (isFromInspectable || !toActivate) return true\n            else return Reflect.set(target, prop, newVal, receiver);\n        },\n        // deleteProperty(target, key) {\n        //     console.log('Delete', key)\n        //     // if (!(key in target)) { return false; }\n        //     // return target.removeItem(key);\n        //     return true\n        // }\n    }\n}\n", "import { fromInspectable, isProxy } from \"../globals\"\n\nfunction define(key, registerAsNewKey: boolean) {\n\n    const inspectable = this\n\n    const target = this.target\n\n    if (!this.parent) {\n        let value = target[key]\n\n            try {\n                Object.defineProperty(target, key, {\n                    get: () => value,\n\n                    // Support setting from inspectable too\n                    set: function (val) {\n                        value = val\n                        inspectable.proxy[key] = {[isProxy]: this[isProxy], [fromInspectable]: true, value: val}\n                    },\n                    enumerable: true,\n                    configurable: true // TODO: Ensure that you are removing later...\n                })\n\n            } catch (e) {\n                console.error(`Could not reassign ${key} to a top-level setter...`)\n            }\n    }\n\n    if (registerAsNewKey) this.newKeys.add(key)\n\n    // Create More Proxies Inside\n    this.create(key, target, undefined, true)\n}\n\nexport default define;", "export const isNode = typeof process === 'object'\n", "import * as handlers from './handlers';\nimport * as check from '../../../common/check'\nimport { ArrayPath, ListenerRegistry, InspectableOptions } from '../types';\nimport * as standards from '../../../../spec/standards'\nimport { setFromPath } from '../../../common/pathHelpers';\nimport { isProxy } from '../globals';\nimport define from './define';\nimport { isNode } from '../../../common/globals';\n\nexport type InspectableProxy = ProxyConstructor & {\n    __proxy: ProxyConstructor,\n    __esInspectable: Inspectable\n}\n\n\nconst canCreate = (parent, key?, val?) => {\n\n    try {\n        if (val === undefined) val = parent[key]\n    } catch (e) {\n        return e\n    }\n\n    // Check if we already have a proxy\n    const alreadyIs = parent[key] && parent[key][isProxy]\n    if (alreadyIs) return false // Already a proxy\n\n\n    const type = typeof val\n    const isObject = type === 'object'\n    const isFunction = type == 'function'\n    \n\n    // Only listen to objects and functions\n    const notObjOrFunc = !val || !(isObject || isFunction )\n    if (notObjOrFunc) return false\n\n    if (!isNode && val instanceof Element) return false // Avoid HTML elements\n    if (val instanceof EventTarget) return false // Avoid HTML elements\n\n    const isESM = isObject && check.esm(val)\n\n    if (isFunction) return true\n    else {\n        \n        const desc = Object.getOwnPropertyDescriptor(parent, key)\n\n        if (desc &&((desc.value && desc.writable) || desc.set)) {\n            if (!isESM) return true // Cannot create a Proxy object for ESM\n        } else if (!parent.hasOwnProperty(key)) return true\n    }\n\n    return false\n\n}\n\nexport default class Inspectable {\n\n    path: ArrayPath = []\n    parent?: Inspectable\n    options: InspectableOptions\n    proxy: ProxyConstructor\n    listeners: Partial<ListenerRegistry> = {}\n    newKeys = new Set()\n\n    target: any\n    root: any\n\n    state: {[x:string]: any} = {}\n\n    constructor ( target:any = {}, opts: Partial<InspectableOptions> = {}, name?, parent?) {\n\n        if (!opts.pathFormat) opts.pathFormat = 'relative'\n        if (!opts.keySeparator) opts.keySeparator = standards.keySeparator\n\n        // -------------- Only Listen to ES Components --------------\n\n        if (target.__proxy) this.proxy = target.__proxy\n        else if (target[isProxy]) this.proxy = target\n        else {\n\n            this.target = target\n            this.options = opts as InspectableOptions\n            this.parent = parent\n\n            if (this.parent) {\n                this.root = this.parent.root\n                this.path = [...this.parent.path]\n                this.state = this.parent.state ?? {} // Share state with the parent\n            } else this.root = target\n\n            if (name) this.path.push(name)\n            if (this.options.listeners) this.listeners = this.options.listeners\n\n            if (this.options.path) {\n                if (this.options.path instanceof Function) this.path = this.options.path(this.path)\n                else if (Array.isArray(this.options.path)) this.path = this.options.path\n                else console.log('Invalid path', this.options.path)\n            }\n\n            // remove symbols from the path\n            if (this.path) this.path = this.path.filter(str => typeof str === 'string')\n\n\n            if (!this.options.keySeparator) this.options.keySeparator = standards.keySeparator\n\n            let type = this.options.type\n            if (type != 'object') type = (typeof target === 'function')  ? 'function' : 'object';\n\n            let handler =  handlers[`${type}s`].call(this)\n            if (type === 'function') handler = {...handler, ...handlers.objects.call(this)} // Functions have both\n\n            this.proxy = new Proxy(target, handler)\n\n            // Set status on original\n            Object.defineProperty(target, '__proxy', { value: this.proxy, enumerable: false })\n            Object.defineProperty(target, '__esInspectable', { value: this, enumerable: false })\n\n\n            // Create Nested Inspectable Proxies\n            for (let key in target) define.call(this, key)\n        }\n\n        return this.proxy as any // Replace class passed to the user with the proxy\n\n    }\n\n    set = (path, info, update) => {\n\n        this.state[path] = {\n            output: update,\n            value: info,\n        }\n\n        // Set on Proxy Object\n        setFromPath(path, update, this.proxy, { create: true });\n    }\n\n    check = canCreate\n\n    create = (key, parent, val?, set = false) => {\n\n        const create = this.check(parent, key, val)\n        if (val === undefined) val = parent[key] \n\n        if (create && !(create instanceof Error)) {\n            parent[key] = new Inspectable(val, this.options, key, this)\n            return parent[key]\n        }\n\n        if (set) {\n            try {\n                this.proxy[key] = val ?? parent[key] // Notify on initialization\n            } catch (e) {\n                const isESM = check.esm(parent)\n                const path = [...this.path, key]\n                console.error(`Could not set value (${path.join(this.options.keySeparator)})${isESM ? ' because the parent is an ESM.' : ''}`, isESM ? '' : e)\n            }\n        }\n\n        return\n    }\n}", "import { setFromPath } from \"../../common/pathHelpers\"\nimport Inspectable from \"./inspectable\"\nimport { MonitorOptions, SetFromOptionsType } from \"./types\"\n\nexport const setFromOptions = (path, value, baseOptions: MonitorOptions, opts: SetFromOptionsType) => {\n\n        const ref = opts.reference\n        \n        const id = (Array.isArray(path)) ? path[0] : (typeof path === 'string') ? path.split(baseOptions.keySeparator)[0] : path\n        let isDynamic = opts.hasOwnProperty('static') ? !opts.static : false\n\n        if (isDynamic && !globalThis.Proxy) {\n            isDynamic = false\n            console.warn('Falling back to using function interception and setters...')\n        }\n\n        if (isDynamic) {\n            value = new Inspectable(value, {\n                pathFormat: baseOptions.pathFormat,\n                keySeparator: baseOptions.keySeparator,\n                listeners: opts.listeners,\n                path: (path) => path.filter((str) => !baseOptions.fallbacks || !baseOptions.fallbacks.includes(str)),\n                // listenDeeper: ['__path'],\n                // listenDeeper: ['test']\n            }, id)\n        }\n\n        let options = {keySeparator: baseOptions.keySeparator, ...opts}\n        setFromPath(path, value, ref, options)\n\n        return value\n    }", "import { esm } from './check.js'\n\nexport const abortSymbol = Symbol('abort')\n\n\nconst getObjectInfo = (obj, path = []) => {\n    return {\n        typeof: typeof obj,\n        name: obj?.constructor?.name,\n        simple: true,\n        object: obj && typeof obj === 'object',\n        path\n    }\n}\n\nexport const drillSimple = (obj, callback, options = {}) => {\n\n    let accumulator = options.accumulator\n    if (!accumulator) accumulator = options.accumulator = {}\n\n    const ignore = options.ignore || []\n    const path = options.path || []\n    const condition = options.condition ||  true\n\n    const seen = []\n    const fromSeen = []\n    \n    let drill = (obj, acc={}, globalInfo) => {\n\n\n        const path = globalInfo.path\n        if (path.length === 0) {\n            const toPass = condition instanceof Function ? condition(undefined, obj, { ...getObjectInfo(obj, path) }) : condition\n            if (!toPass) return obj // Allow skipping top-level objects too\n        }\n\n        for (let key in obj) {\n            if (options.abort) return\n            if (ignore.includes(key)) continue\n\n            const val = obj[key]\n            const newPath = [...path, key]\n\n            const info = getObjectInfo(val, newPath)\n\n            if (info.object) {\n                const name = info.name\n\n                const isESM = esm(val) // make sure to catch ESM\n\n                if (isESM || name === 'Object' || name === 'Array') {\n                    info.simple = true\n                    const idx = seen.indexOf(val)\n                    if (idx !== -1) acc[key] =fromSeen[idx]\n                    else {\n                        seen.push(val)\n\n                        const pass = condition instanceof Function ? condition(key, val, info) : condition\n                        info.pass = pass\n                        \n                        const res = callback(key, val, info)\n                        if (res === abortSymbol) return abortSymbol\n                        acc[key] = res\n\n                        if (pass) {\n                            fromSeen.push(acc[key])\n                            const res = drill(val, acc[key], {...globalInfo, path: newPath}) // Drill simple objects\n                            if (res === abortSymbol) return abortSymbol\n                            acc[key] = res\n                        }\n                    }\n                } \n                else {\n                    info.simple = false\n                    const res =  callback(key, val, info)\n                    if (res === abortSymbol) return abortSymbol\n                    acc[key] = res\n                }\n            } else {\n                const res =  callback(key, val, info)\n                if (res === abortSymbol) return abortSymbol\n                acc[key] = res\n            }\n\n\n        } \n\n        return acc\n    }\n\n    return drill(obj, accumulator, { path })\n}", "import * as check from '../../common/check'\nimport Poller from './Poller'\n\nimport { PathFormat, InternalOptions, ListenerRegistry, ArrayPath, MonitorOptions, SetFromOptionsType } from './types'\nimport * as listeners from './listeners'\nimport { iterateSymbols, getPath, getPathInfo } from './utils'\nimport { drillSimple } from '../../common/drill'\nimport { getFromPath } from '../../common/pathHelpers'\n\nimport * as standards from '../../../spec/standards'\nimport { setFromOptions } from './optionsHelpers'\n\nconst createLookup = () => {\n    return { symbol: {}, name: {} }\n}\n\n\nconst isNode = typeof process === 'object'\n\nexport default class Monitor {\n\n    poller = new Poller()\n\n    options: MonitorOptions = {\n        pathFormat: 'relative',\n        keySeparator: standards.keySeparator,\n    }\n    \n    listeners: ListenerRegistry = {\n        polling: this.poller.listeners,\n        functions: {},\n        setters: {},\n        lookup: createLookup()\n    }\n\n    references: {\n        [x:string | symbol]: {\n            [x:string | symbol]: any\n        }\n    } = {}\n\n    constructor(opts:Partial<MonitorOptions>={}){\n\n        // Make listener lookup non-enumerable\n        Object.defineProperty(this.listeners, 'lookup', {\n            value: createLookup(),\n            enumerable: false,\n            configurable: false\n        })\n\n        Object.assign(this.options, opts)\n        this.poller.setOptions(opts.polling)\n    }\n\n    get = (path, output?, reference = this.references) => {\n        return getFromPath(reference, path, {\n            keySeparator: this.options.keySeparator,\n            fallbacks: this.options.fallbacks,\n            output\n        })\n    }\n\n    set = (path, value, opts: SetFromOptionsType= {}) => {\n\n        const optsCopy = {...opts}\n        if (!optsCopy.reference) optsCopy.reference = this.references\n        if (!optsCopy.listeners) optsCopy.listeners = this.listeners\n\n        const set = setFromOptions(path, value, this.options, optsCopy)\n        return set\n    }\n\n    // A simple wrapper for listen()\n    on = (absPath: PathFormat, callback) => {\n        const info = getPathInfo(absPath, this.options)\n        return this.listen(info.id, callback, info.path)\n    }\n\n\n    getInfo = (label, callback, path, original) => {\n\n        const info = listeners.info(label, callback, path, original, this.references, this.listeners, this.options)\n        const id = Math.random()\n        const lookups = this.listeners.lookup\n        const name = getPath('absolute', info)\n        lookups.symbol[info.sub] = {\n            name,\n            id\n        }\n\n        if (!lookups.name[name]) lookups.name[name] = {}\n        lookups.name[name][id] = info.sub\n        \n        return info\n    }\n\n    listen = (id, callback, path: PathFormat = [], __internal: Partial<InternalOptions> = {}) => {\n\n\n        if (typeof path === 'string') path = path.split(this.options.keySeparator)\n        else if (typeof path === 'symbol') path = [path]\n\n        const arrayPath = path as ArrayPath\n\n        let baseRef = this.get(id)\n\n        if (!baseRef) {\n            console.error(`Reference does not exist.`, id)\n            return\n        }\n\n\n        if (!__internal.poll) __internal.poll = check.esm(baseRef) // Inherit ESM status\n        if (!__internal.seen) __internal.seen = []\n\n        const __internalComplete = __internal as InternalOptions\n\n        // Drill Reference based on Path\n        const thisPath = [id, ...arrayPath]\n        const ref = this.get(thisPath)\n\n\n        // Create listeners for Objects\n        const toMonitorInternally = (val, allowArrays=false) => {\n            const first = val && typeof val === 'object'\n            \n            // Only Objects\n            if (!first) return false\n\n            // No Elements\n            if (!isNode) {\n                const isEl = val instanceof Element\n                if(isEl) return false\n            }\n\n            if (allowArrays) return true\n            else return !Array.isArray(val)\n        }\n\n\n        // ------------------ Create Subscription ------------------\n\n        // Case #1: Subscribe to each object property individually\n        let subs = {}\n        let success = false\n        const subscribeAll = toMonitorInternally(ref, true)\n        if (subscribeAll) {\n\n            if (ref.__esInspectable) ref.__esInspectable.options.globalCallback = callback\n\n            drillSimple(ref, (_, __, drillInfo) => {\n                if (drillInfo.pass) return \n                else {\n                    const fullPath = [...arrayPath, ...drillInfo.path]\n                    const internalSubs = this.listen(id, callback, fullPath, __internalComplete) // subscribe to all\n                    Object.assign(subs, internalSubs)\n                }\n            }, {\n                condition: (_, val) => toMonitorInternally(val)\n            })\n\n            success = true\n        } \n\n        // Case #2: Subscribe to specific property\n        let info;\n        try {\n            \n            // Force Polling\n            info = this.getInfo(id, callback, arrayPath, ref)\n\n            if (info && !success) {\n                if (__internalComplete.poll) success = this.poller.add(info)\n\n                // Direct Methods\n                else {\n\n                    let type = 'setters' // trigger setters\n                    if (typeof ref === 'function') type = 'functions' // intercept function calls\n\n                    success = this.add(type, info)\n                }\n            }\n            \n        } catch (e) {\n            console.error('Fallback to polling:', path, e)\n            success = this.poller.add(info)\n            // __internalComplete.poll = true\n        }\n        \n\n        if (success) {\n            subs[getPath('absolute', info)] = info.sub\n\n            // Notify User of Initialization\n            if (this.options.onInit instanceof Function) {\n                const executionInfo = {}\n                for (let key in info.infoToOutput) executionInfo[key] = undefined\n                this.options.onInit(getPath('output', info), executionInfo)\n            }\n\n            return subs\n        } else {\n            console.error('Failed to subscribe to:', path)\n            return\n        }\n    }\n\n    add = (type, info) => {\n        if (listeners[type]) return listeners[type](info, this.listeners, this.listeners.lookup)\n        else {\n            this.listeners[type][getPath('absolute', info)][info.sub] = info\n            return true\n        }\n    }\n\n    // Unsubscribe from a subscription\n    remove = (subs) => {\n\n        // Clear All Subscriptions if None Specified\n        if (!subs) {\n            subs = {\n                ...this.listeners.functions,\n                ...this.listeners.setters,\n                ...this.listeners.polling,\n            }\n        }\n\n\n        if (typeof subs!== 'object') subs = { sub: subs }\n\n        for (let key in subs) {\n\n            let innerSub = subs[key]\n\n            const handleUnsubscribe = (sub) => {\n                const res = this.unsubscribe(sub)\n                if (res === false) console.warn(`Subscription for ${key} does not exist.`, sub)\n            }\n\n            if (typeof innerSub !== 'symbol') iterateSymbols(innerSub, handleUnsubscribe)\n            else handleUnsubscribe(innerSub)\n        }\n\n        return true \n    }\n\n    unsubscribe = (sub) => {\n            const info = this.listeners.lookup.symbol[sub]\n            const absPath = info.name\n\n            // Remove from Polling listeners\n            const polling = this.poller.get(sub)\n\n            const funcs = this.listeners.functions[absPath]\n            const func = funcs?.[sub]\n            const setters = this.listeners.setters[absPath]\n            const setter = setters?.[sub]\n\n            if (polling) this.poller.remove(sub)\n            \n            // Reassign to Original Function\n            else if (func) {\n                delete funcs[sub]\n                if (!Object.getOwnPropertySymbols(funcs).length) {\n                    Object.defineProperty(func.parent, func.last, {\n                        value: func.original,\n                        writable: true\n                    })\n                    delete this.listeners.functions[absPath]\n                }\n            }\n            \n            // Transition Back to Standard Object\n            else if (setter) {\n                delete setters[sub]\n                if (!Object.getOwnPropertySymbols(setters).length) {\n                    const parent = setter.parent\n                    if (parent) {\n                        const last = setter.last\n                        const value = parent[last] // Parent always exists!\n                        Object.defineProperty(parent, last, { value, writable: true })\n                    }\n                    delete this.listeners.setters[absPath]\n                }\n            } else return false\n\n            delete this.listeners.lookup.symbol[sub] // Remove from global listener collection\n\n            const nameLookup = this.listeners.lookup.name[info.name]\n            delete nameLookup[info.id]\n            if (!Object.getOwnPropertyNames(nameLookup).length )delete this.listeners.lookup.name[info.name]\n\n    }\n}", "import Monitor from './Monitor'\n\n\n\nexport default Monitor \n\n// export {\n//     Monitor\n// }", "\n// ------------ Get All Property Names ------------\n\nconst rawProperties = {}\nconst globalObjects = ['Object', 'Array', 'Map', 'Set']\n\nexport function all( obj: any ) {\n\n    var props: string[] = [];\n    if (obj) {\n        do {\n\n            const name = obj.constructor?.name \n            const isGlobalObject = globalObjects.includes(name)\n            if (globalObjects.includes(name)) {\n                if (!rawProperties[name]) rawProperties[name] = [...Object.getOwnPropertyNames(globalThis[name].prototype)]\n            }\n\n            Object.getOwnPropertyNames( obj ).forEach(function ( prop ) {\n                if (isGlobalObject && rawProperties[name].includes(prop)) return; // Skip inbuilt class prototypes\n                if ( props.indexOf( prop ) === -1 ) props.push( prop )\n            });\n        } while ( obj = Object.getPrototypeOf( obj ));\n    }\n\n    return props;\n}\n", "import { drillSimple } from \"./drill\"\nimport { all } from \"./properties\"\n\nexport const shallow = (obj, opts={}) => {\n    if (typeof obj === 'object') {\n        if (Array.isArray(obj)) {\n            obj = [...obj] // Clone the orignal object\n            opts.accumulator = []\n        } else {\n            const keys = all(obj)\n            const newObj = {}\n            for (let key of keys)  newObj[key] = obj[key] // Clone the orignal object\n            obj = newObj\n            opts.accumulator =  {}\n        }\n    }\n\n    return obj\n}\n\nexport const deep = (obj, opts={}) => {\n    if (typeof obj !== 'object') return obj\n    obj = shallow(obj, opts)\n\n    drillSimple(obj, (key, val, info) => {\n        if (info.simple && info.object) return Array.isArray(val) ? [] : {}\n        // else if (info.typeof === 'function') return val.bind({})\n        else return val\n    }, opts)\n\n    return opts.accumulator\n}", "import { shallow } from \"../clone\"\nimport { all } from \"../properties\"\n\nconst isPromise = (o) => typeof o === 'object' && typeof o.then === 'function'\n\n// Resolve if promise or object\nexport const resolve = (object, callback?) => {\n\n    // can resolve arrays with promises\n    if (typeof object === 'object' && Array.isArray(object) && object.find(v => isPromise(v))) object = Promise.all(object)\n\n    // resolves with or without callback \n    if (isPromise(object)) {\n        return new Promise(resolvePromise => {\n            object.then(async (res) => {\n                const output = (callback) ? callback(res) : res\n                resolvePromise(output)\n            })\n        })\n    } else {\n        return (callback) ? callback(object) : object\n    }\n}\n\n// ------------ Merge ------------\n// Merge individual object keys AND nest functions to maintain their bindings\n// -------------------------------\n\n\nconst functionRegistry: {\n    f: Function,\n    list: Function[]\n}[] = []\n\nexport const merge = (\n    main, \n    override, \n    updateOriginal: boolean = false, // choose to update original\n    flipPrecedence: boolean = false, // flip precedence of merge\n    composeFunctions: boolean = false, // use composition on functions\n    seen: any[]=[], // for circular references\n) => {\n\n    let copy = (updateOriginal) ? main : shallow(main) // choose to copy\n\n    if (flipPrecedence) [copy, override] = [override, copy]\n\n\n    if (override){\n\n        const keys = all(copy)\n        const newKeys = new Set(all(override))\n\n        keys.forEach(k => {\n            newKeys.delete(k)\n\n            const exists = k in override\n            const newValue = override[k]\n            if (exists && newValue === undefined)  delete copy[k] // delete if undefined\n\n            // Merge individual object keys\n            else if (typeof newValue === 'object' && !Array.isArray(newValue)) {\n\n                    // Track seen so you don't drill infinitely on circular references\n                    if (typeof copy[k] === 'object') {\n                        const val = copy[k]\n                        const idx = seen.indexOf(val)\n                        if (idx !== -1) copy[k] = seen[idx]\n                        else {\n                            seen.push(val)\n                            copy[k] =  merge(val, newValue, updateOriginal, false, composeFunctions, seen)\n                        }\n                    }\n                    else copy[k] = newValue\n            } \n\n            // Nest functions\n            else if (typeof newValue === 'function') {\n\n                const original = copy[k]\n                const isFunc = typeof original === 'function'\n\n                const newFunc = newValue\n                const composeFunction = newFunc.__compose === true\n\n                // Direct Function Replacement\n                if (!isFunc || (!composeFunctions && !composeFunction)) copy[k] = newFunc\n                \n                // Function Composition\n                else {\n                    let funcList = functionRegistry.find(o => o.f === original)\n\n                    let ogFunc = original\n                    if (!funcList) {\n                        if (ogFunc.__esInspectable) ogFunc = ogFunc.__esInspectable.target // Don't trigger proxies that have been updated\n                        funcList = {f: ogFunc, list: [ogFunc]}\n                        functionRegistry.push(funcList)\n                    }\n\n                    if (!funcList.list.includes(newFunc)) {\n                        const func = copy[k] = function(...args) {\n                            const res = ogFunc.call(this, ...args);\n                            return newFunc.call(this, ...Array.isArray(res) ? res : [res]);\n                        } as Function & {__functionList?: Function[]}\n\n                        funcList.f = func\n                        funcList.list.push(newFunc)\n                    } \n                    else console.warn(`This function was already composed. Ignoring duplicate.`)\n                }\n\n            }\n            \n            // Replace values and arrays\n            else if (k in override) copy[k] = newValue\n        })\n\n\n        newKeys.forEach(k => {\n            const newValue = override[k]\n            if (newValue === undefined) return\n            else copy[k] = newValue\n        })\n    }\n\n    return copy // named exports\n}\n\nexport function isNativeClass (thing) {\n    return isFunction(thing) === 'class'\n}\n\n\nexport function isFunction(x) {\n    const res = typeof x === 'function'\n        ? x.prototype\n            ? Object.getOwnPropertyDescriptor(x, 'prototype').writable\n                ? 'function'\n                : 'class'\n        : x.constructor.name === 'AsyncFunction'\n        ? 'async'\n        : 'arrow'\n    : '';\n\n    return res\n}\n", "const fetchAndInstantiateTask = async (uri, importObject) => {\n    const wasmArrayBuffer = await fetch(uri).then(response => response.arrayBuffer());\n    return WebAssembly.instantiate(wasmArrayBuffer, importObject);\n};\n\n// https://github.com/torch2424/wasm-by-example/blob/master/demo-util/\nconst load = async (uri, importObject) => {\n\n    if (!importObject) importObject = { env: { abort: () => console.log(\"Abort!\") } };\n\n    if (WebAssembly.instantiateStreaming) return await WebAssembly.instantiateStreaming( fetch(uri), importObject );\n    else return await fetchAndInstantiateTask(uri, importObject);\n};\n\nexport default load", "import { Options } from \"../../common/types\"\nimport { specialKeys } from \"../../../spec/standards\"\nimport { deep as deepClone } from \"../../common/clone\"\n\nimport wasm from './wasm'\n\n\nconst catchError = (o, e) => {\n    // Insert an Error Component\n    if (o[specialKeys.reference]) {\n        console.warn('[escode]: Falling back to ES Component reference...', e)\n        return o[specialKeys.reference] // fallback to reference key\n    }\n    else return createErrorComponent(e.message)\n}\n\nconst genericErrorMessage = `Cannot transform ${specialKeys.compose} string without a compose utility function`\n\nexport default function compile(o, opts: Options) {\n            \n    // Special URL key\n    let uri = (typeof o === 'string') ? o : o[specialKeys.uri]\n\n    if (uri && uri.slice(-5) === '.wasm') {\n        let relTo = o.relativeTo ?? opts?.relativeTo ?? window.location.href\n        if (relTo.slice(-1)[0] !== '/') relTo += '/'\n        const absoluteURI = new URL(uri, relTo).href\n        return new Promise(async (resolve) =>  {\n            const info = await wasm(absoluteURI, o.importOptions)\n            const copy = Object.assign({}, info.instance.exports) as any\n            // WebAssembly Support\n            for (let key in copy){\n                const val = copy[key]\n                if (val instanceof WebAssembly.Memory) copy[key] = new Uint8Array(val.buffer); // Replace Memory with Typed Array\n                else if (val instanceof WebAssembly.Global) {\n                    Object.defineProperty(copy, key, {\n                        get: () => val.value,\n                        set: (v) => val.value = v\n                    })\n                }\n            }\n\n            resolve(copy)\n        })\n    }\n\n    else if (uri && opts.utilities) {\n\n        // Get Text Bundle\n        const bundleOpts = opts.utilities.bundle\n        const gotBundleOpts = bundleOpts && typeof bundleOpts.function === 'function'\n        const compileOpts = opts.utilities.compile\n        const gotCompileOpts  = compileOpts && typeof compileOpts.function === 'function'\n        \n        if (!gotBundleOpts && !gotCompileOpts) o = catchError(o, new Error(genericErrorMessage))\n        else {\n            return new Promise(async (resolve) => {\n\n                try {\n\n                    if (gotBundleOpts) {\n                        const options = bundleOpts.options ?? {}\n                        if (!options.bundler) options.bundler = 'datauri' // link as datauri\n                        if (!options.bundle) options.collection ='global' // same collection across all instances on the page\n                        if (!options.relativeTo) options.relativeTo = opts.relativeTo ?? '.' // Specify relativeTo in different locations\n                        const bundle = bundleOpts.function(uri, options)\n\n                        // Track Bundle Resolution\n                        await bundle.compile()\n\n                        o = Object.assign({}, bundle.result)\n                    } \n                    \n                    // Just Compile\n                    else if (gotCompileOpts) {\n                        const options = compileOpts.options ?? {}\n                        if (!options.relativeTo) options.relativeTo = opts.relativeTo ?? '.' // Specify relativeTo in different locations\n                        const resolved = await compileOpts.function(o, options)\n                        o = resolved\n                    } \n                    \n                    // Show Error Message\n                    else {\n                        throw new Error(genericErrorMessage)\n                    }\n                } catch (e) { \n                    o = catchError(o, e)       \n                }\n\n                resolve(deepClone(o))\n            })\n        }\n    }\n\n    return deepClone(o[specialKeys.reference] ?? o) \n}\n\n\nfunction createErrorComponent (message) {\n    return {\n        [specialKeys.element]: 'p',\n        b: {\n            [specialKeys.element]: 'b',\n            [specialKeys.attributes]: {\n                innerText: 'Error: '\n            }\n        },\n        span: {\n            [specialKeys.element]: 'span',\n            [specialKeys.attributes]: {\n                innerText: message\n            }\n        }\n    }\n}", "// Utilities\nimport { resolve, merge as basicMerge } from \"../common/utils\"\n\n// Helpers\nimport compile from './compile'\nimport { esSourceKey, specialKeys } from '../../spec/standards'\n\ntype anyObj = {[key: string]: any}\ntype esComposeType = anyObj | anyObj[]\n\n\nexport const name = 'compose'\n\nconst localSpecialKeys = {\n    compose: specialKeys.compose,\n    apply: specialKeys.apply,\n\n    // Added with library\n    bundle: esSourceKey\n}\n\nexport const behavior = 'load'\n// export const behavior = 'set'\n// export const behavior = 'start'\n// export const behavior = 'stop'\n\nexport const properties = {\n    dependents:  Object.values(localSpecialKeys),\n}\n\nconst isPathString = (value) => typeof value === 'string' && (value.includes('/') || value.includes('.'))\n\n// ------------ Composition Loader Function ------------\n// This function is used to load the __compose property of an object\n// -----------------------------------------------------\nfunction compose(o, toApply, opts, updateOriginal=false) {\n    \n    o = basicMerge(o, toApply, updateOriginal); // basic merge\n\n    o = compileAndMerge(o, o[localSpecialKeys.compose], opts, true, updateOriginal) // Basic Composition Support\n\n    return resolve(o, (o) => {\n\n        // ------------------ Set __apply Properties on Composition ------------------\n        const toApply = o[localSpecialKeys.apply]\n        const toApplyFlag = (toApply && (typeof toApply === 'object' || isPathString(toApply)))\n        o = toApplyFlag ? compileAndMerge(o,toApply, opts, false, updateOriginal) : o // Reverse Composition Support\n        return resolve(o)\n    })\n}\n\nexport default compose\n\n// ------------ Merge Helper ------------\n// This merge function is used to merge two objects together WHILE RESOLVING COMPONENTS THAT MUST BE COMPILED\n// --------------------------------------\nfunction compileAndMerge(properties, composition: esComposeType = {}, opts: any = {}, flipPrecedence=false, updateOriginal=false) {\n\n    // Ensure __compose is an array\n    if (!Array.isArray(composition)) composition = [composition]\n\n    // Merge nested __compose objects\n    let promise = resolve(composition.map(o => {\n       const compiled = compile(o, opts) // Resolve from text if required\n\n       const checkAndPushTo = (target, acc: any[] = [], forcePush = true) => {\n\n        if (Array.isArray(target)) target.forEach(o => checkAndPushTo(o, acc), true)\n\n        else if (target[localSpecialKeys.compose]) { \n\n                acc.push(target)\n\n                const val = target[localSpecialKeys.compose]    \n                delete target[localSpecialKeys.compose]\n                const newTarget = resolve(compile(val, opts)) // Resolve from text if required\n                checkAndPushTo(newTarget, acc)\n        }\n        else if (forcePush) acc.push(target)\n\n        return acc\n       }\n       \n       return resolve(compiled, (compiled) => checkAndPushTo(compiled))\n    }))\n\n    return resolve(promise, (composition) => {\n\n        const flat = composition.flat();\n\n        let composed = {}\n\n        flat.forEach((toCompose) => composed = basicMerge(\n            composed, \n            toCompose, \n            false, \n            false, \n            // true // NOTE: Would allow functions to be nested inside each other\n        ));\n\n        return basicMerge(\n            properties, \n            composed, \n            updateOriginal, \n            flipPrecedence, \n            // true\n        );\n    })\n}", "export const toReturn = Symbol('return')", "import { Options } from \"../common/types\"\nimport { keySeparator, specialKeys } from \"../../spec/standards\"\nimport Monitor from \"../esmonitor/src\"\nimport { deep as deepClone } from \"../common/clone\"\nimport { AnyClass, ConfigInput, FinalConfig } from \"./types\"\n\n// TODO: Completely separate here...\nimport compose from \"../escode-compose-loader\"\nimport { toReturn } from \"./symbols\"\nimport { isNode } from \"../common/globals\"\n\nconst isNativeClass= (o) => typeof o === 'function' && o.hasOwnProperty('prototype') && !o.hasOwnProperty('arguments')\n\n// This function accepts pre-parsed configuration objects and returns a final configuration object\nexport default function parse(config: ConfigInput, toApply: any = {}, options: Partial<Options> = {}) {\n\n    if (!isNode) {\n        if (config instanceof NodeList) config = Array.from(config)  // DOM NodeList Support (e.g. from querySelectorAll): Converts to an array of configurations\n    }\n\n\n    if ( typeof config === 'string') config =  { [specialKeys.apply]: config } // String Support: Transform string so that it is compiled from source\n\n    // Function Support: Transform function so that it becomes an object\n    else if ( typeof config === 'function') {\n        if (isNativeClass(config)) config = new (config as AnyClass)(toApply, options) // Create a class\n        else {\n            delete (config as any).__ // remove a triggering __ property from the function\n            config = { [specialKeys.default]: config } // Apply as a default function\n        }\n    }\n\n    // Apply Component to the Element\n    else if (!isNode && config instanceof Element) {\n        const component = config[specialKeys.component]\n\n        // Directly Merge into existing element + component pairs (TO FINISH)\n        if (component) {\n\n            toApply = deepClone(toApply) // Clone the applied object to prevent mutation\n\n            // We cannot handle the compose and apply keywords the same way\u2014so we will approximate here.\n            const shouldHaveComposed = toApply.__compose\n            const shouldHaveApplied = toApply.__apply\n            delete toApply.__compose\n            delete toApply.__apply\n\n            if (shouldHaveComposed) {\n                console.warn('Cannot compose a component onto an element that already has a component. Merging with the base object instead...')\n                toApply = Object.assign(shouldHaveComposed, toApply)\n            }\n\n            if (shouldHaveApplied) {\n                console.warn('Cannot apply a component onto an element that already has a component. Applying to the base object instead...')\n                toApply = Object.assign(toApply, shouldHaveApplied)\n            }\n\n            compose(component, toApply, options, true)  // Complete a reverse composition to apply to an existing component\n\n            return {[toReturn]: component} // shortcut to stop and return the existing component\n        }\n        // Create new component with element as the base\n        else {\n            config = { [specialKeys.element]: config } // Compile element to object\n        }\n    }\n\n    // Bulk Operations\n    else if (Array.isArray(config)) return config // return array to be handled\n\n    // Failed Resolution\n    else if ( typeof config === 'object') {\n        config = (options.clone !== false ? deepClone(config) : config)\n    }\n\n    else throw new Error(`Invalid configuration type: ${ typeof config }. Expected object or string.`)   \n    \n    // -------------- Assign Standard Properties to the Component Object --------------         \n    return config as FinalConfig\n}\n\n\n // -------------- Create Complete Options Object --------------         \nexport const parseOptions = (options: Partial<Options>) => {\n const copy = deepClone(options)\n let monitor;\n if (copy.monitor instanceof Monitor) {\n     monitor = copy.monitor\n     copy.keySeparator = monitor.keySeparator // Inherit key separator\n } else {\n     if (!copy.monitor) copy.monitor = {}\n     if (!copy.monitor.keySeparator) {\n         if (!copy.keySeparator) copy.keySeparator = keySeparator // Ensure key separator is defined\n         copy.monitor.keySeparator = copy.keySeparator\n     }\n     copy.monitor = new Monitor(copy.monitor)\n }\n\n return copy as Options\n}", "globalThis.escomposePerformance = {\n    create: [],\n    resolve: [],\n    resolveAll: [],\n    listeners: {\n        create: [],\n        resolve: [],\n    },\n    averages: function () {\n\n        const averages = {\n            create: 0,\n            resolve: 0,\n            resolveAll: 0,\n            listeners: {\n                create: 0,\n                resolve: 0,\n            }\n        }\n\n        for (const key in averages) {\n            if (typeof this[key] === 'object' && !Array.isArray(this[key])) {\n                for (const subKey in this[key]) {\n                    averages[key][subKey] = this[key][subKey].reduce((a, b) => a + b, 0) / this[key][subKey].length\n                }\n            } else averages[key] = this[key].reduce((a, b) => a + b, 0) / this[key].length\n        }\n        return averages\n    }\n}", "// import { Graph } from \"../../../Graph2\"\n\nimport '../globals'\n\n// Special Key Definition\nconst defaultPath = 'default'\nconst operatorPath = '__operator'\nconst specialKeys = {\n    path: '__path',\n    isGraphScript: '__',\n    listeners: {\n        value: '__listeners',\n        branch: '__branch',\n        bind: '__bind',\n        trigger: '__trigger',\n        format: '__format',\n    },\n}\n\n// Symbols to Recognize\nconst listenerObject = Symbol('listenerObject')\nconst toSet = Symbol('toSet')\nconst subscriptionKey = Symbol('subscriptionKey')\nconst configKey = Symbol('configKey')\nconst toResolveWithKey = Symbol('toResolveWithKey')\n\n// Configuration Options\nconst isConfigObject = (o) => specialKeys.listeners.format in o || specialKeys.listeners.branch in o || specialKeys.listeners.trigger in o || specialKeys.listeners.bind in o\n\n// Status Definitions\nconst initializedStatus = 'INITIALIZED'\nconst registeredStatus = 'REGISTERED'\n\n// Global References\nconst globalFrom = {} as any\nconst globalTo = {} as any\nconst globalActive = {}\n\nclass Edgelord {\n\n    original = {};\n    active = {}\n    globals: any = {}\n    context: any = {\n        options: {},\n    }\n    rootPath: string = ''\n    status = ''\n\n    graph: any // Graph\n    \n    #triggers: any[] = []\n    #queue: any[] = []\n    #toResolveWith: Edgelord\n\n    constructor (listeners?, root?, context?) {\n        if (listeners || root || context) this.setInitialProperties(listeners, root, context)\n    }\n\n    setInitialProperties = (listeners = {}, root, context: any ={}) => {\n\n        Object.assign(this.context, context)\n        if (root) this.rootPath = root\n\n        if (!this.context.options.keySeparator) this.context.options.keySeparator = this.context.monitor.options.keySeparator\n        \n        this.original = listeners\n\n        const globals = [{name: 'active', ref: globalActive}, {name: 'from', ref: globalFrom}, {name: 'to', ref: globalTo}]\n        globals.forEach((o) => {\n            if (!o.ref[this.context.id]) o.ref[this.context.id] = {}\n            this.globals[o.name] = o.ref[this.context.id]\n        })\n\n        this.#toResolveWith = this.getManager()\n        this.runEachListener(listeners, this.addToGlobalLog)\n    }\n\n    getManager = (mode ='from') => {\n        \n            // Check if a higher-level listener is sending information from this root context\n            let target = (mode === 'to') ? this.globals.to : this.globals.from\n            this.rootPath.split(this.context.options.keySeparator).forEach((key) => {\n                if (!target[key]) target[key] = {}\n                target = target[key]\n            })\n\n            // if (Object.keys(target).length) this.#sendsToExternalGraph = true\n            return target[toResolveWithKey] ?? this\n    }\n\n    onStart = (f) => {\n        const res = this.#toResolveWith\n        const isSame = res === this\n        if (isSame) {\n            if (this.status === initializedStatus) f()\n            else this.#queue.push(f)\n        } else res.onStart(f)\n    }\n\n    runEachListener = (listeners, callback) => {\n        if (!callback) return\n        for (const first in listeners) {\n            const second = listeners[first]\n\n            if (!second) {\n                console.warn('Skipping empty listener:', first)\n                continue;\n            }\n\n            // NOTE: Listener sheets are to / from\n            if (second && typeof second === 'object') {\n                const from = second\n                const to = first\n                for (let fromPath in from) {\n                    callback(\n                        fromPath,  // From Path\n                        to, // To Path\n                        from[fromPath] // Value\n                    )\n                }\n            } \n            \n            // Immediate Absolute Paths Only\n            // NOTE: Direct listeners are from / to\n            else {\n                const from = first\n                const to = second\n\n                const typeOf = typeof to\n                if (typeOf === 'function') callback(from, '', to)\n                else if (typeOf === 'string') callback(from, to, to)\n                else console.error('Improperly Formatted Listener', to)\n            }\n        }\n\n    }\n\n    register = (listeners = this.original) =>  {\n\n        this.runEachListener(listeners, this.add)\n        this.status = registeredStatus\n    }\n\n    #initialize = (o) => {\n        const res = this.context.monitor.get(o.path, 'info')\n        if (typeof res.value === 'function') {\n            const args = (Array.isArray(o.args)) ? o.args : [o.args]\n            res.value(...args)\n        }\n        else console.error('Cannot yet trigger values...', o)\n    }\n\n    initialize = (o?) => {\n        if (!this.status) this.#triggers.push(o)\n        else if (this.status === registeredStatus) {\n            this.status = initializedStatus\n            this.#triggers.forEach(this.#initialize)\n            this.#queue.forEach(f => f())\n            this.#queue = []\n            this.#triggers = []\n        } else this.#initialize(o)\n    }\n\n    start = () => {\n        this.register()\n        this.initialize()\n    }\n\n    #getAbsolutePath = (name) => {\n        const sep = this.context.monitor.options.keySeparator\n        return (\n            !name \n            || !this.rootPath \n            || (this.rootPath === name.slice(0, this.rootPath.length) && name[this.rootPath.length] === sep)\n        ) ? name : [this.rootPath, name].join(sep)\n    }\n\n    #getPathInfo = (path) => {\n\n        const output = {\n            absolute: {},\n            relative: {}\n        } as any\n\n        // Transform name to absolute \n        path =  this.#getAbsolutePath(path)\n        let rel = this.rootPath ? path.replace(`${this.rootPath}.`, '') : path\n        const baseArr = path.split(this.context.options.keySeparator)\n        output.absolute.array = [this.context.id, ...baseArr]\n        output.relative.array = rel.split(this.context.options.keySeparator)\n\n        let obj = this.context.monitor.get(\n            output.absolute.array,  // For General Use\n            undefined, \n            // this.context.instance, \n        ) // Allow for getting properties\n\n\n        // Fallback to direct graph reference\n        if (this.context.graph) {\n\n            // Correct for paths that are relative to the bound object\n            if (obj && this.context.bound) {\n                output.absolute.array = [this.context.id, this.context.bound, ...output.absolute.array.slice(1)]\n                output.relative.array.unshift(this.context.bound)\n            } \n            \n            // Assume you are targeting the global graph\n            else if (!obj) {\n                const rel = output.relative.array.join(this.context.options.keySeparator)\n                obj = this.context.graph.get(rel)\n            }\n        }\n        \n        const isGraphScript = obj && typeof obj === 'object' && specialKeys.isGraphScript in obj\n\n        // Fallback to default updates\n        const useOperator = obj && isGraphScript && obj[operatorPath]\n        const useDefault = obj && obj[defaultPath]\n        const extraPath = (useOperator) ? operatorPath : (useDefault) ? defaultPath : undefined\n        if (extraPath) {\n            output.absolute.array.push(extraPath)\n            output.relative.array.push(extraPath)\n        }\n\n        output.absolute.value = output.absolute.array.slice(1).join(this.context.options.keySeparator) // update path\n        output.relative.value = output.relative.array.join(this.context.options.keySeparator) // update path\n        \n        return output\n    }\n\n    add = (from, to, value: any = true, subscription?) => {\n\n        const tic = performance.now()\n\n        if (!value) return // Any non-truthy value is not accepted\n\n        const fromInfo = this.#getPathInfo(from)\n        const toInfo = this.#getPathInfo(to)\n\n        // Check global for subscription\n        const absPath = fromInfo.absolute.value\n        if (!subscription) subscription = this.globals.active[absPath]?.[subscriptionKey]\n\n        // Only subscribe once\n        if (!subscription) {\n            subscription =this.context.monitor.on(fromInfo.absolute.array, (path, _, update) => this.activate(path, update), {\n                ref: this.context.instance, // TODO: What does this do?\n                path: fromInfo.relative.array\n            })\n            // console.log('Subscribing', fromInfo.absolute.array, subscription)\n        }\n\n        // Use updated string value if modified\n        if (typeof value == 'string') value = toInfo.absolute.array.slice(1).join(this.context.options.keySeparator)\n\n        const info = {\n            value,\n            [listenerObject]: true\n        }\n\n        const refs = [this.active, this.globals.active]\n\n        refs.forEach(ref => {\n            if(!ref[absPath]) ref[absPath] = {}\n            const base = ref[absPath]\n            if (!base[subscriptionKey]) {\n                Object.defineProperty(base, subscriptionKey, {\n                    value: subscription,\n                    configurable: true\n                })\n            }\n            base[toInfo.absolute.value] = info\n        })\n\n        // // Update Original\n        // let base = this.original[toInfo.relative.value]\n        // if (!base) base = this.original[toInfo.relative.value] = {}\n        // if (typeof base !== 'object') {\n        //     if (typeof base === 'function') base = this.original[toInfo.relative.value] = {[Symbol('function listener')]: base} // Move function to arbitrary key\n        //     else base = this.original[toInfo.relative.value] = {[base]: true} // Move string to  a complex listener\n        // }\n        // base[fromInfo.relative.value] = value // complex listener\n\n        // Initalize triggers (possible on higherl-level manager)\n        const args = value[specialKeys.listeners.trigger]\n        if (args) this.#toResolveWith.initialize({\n            path: fromInfo.absolute.array,\n            args\n        })\n\n        this.addToGlobalLog(absPath)\n\n        const toc = performance.now()\n\n        globalThis.escomposePerformance.listeners.create.push(toc - tic)\n\n        return info\n    }\n\n    addToGlobalLog = (path, mode = 'from') => {\n\n        const absolutePath = this.#getAbsolutePath(path)\n\n        // Register in global registry\n        let target = (mode === 'to') ? this.globals.to : this.globals.from\n        const globalPath = absolutePath.split(this.context.options.keySeparator)\n        globalPath.forEach((key) => {\n            if (!target[key]) target[key] = {}\n            target = target[key]\n            if (!(target[toResolveWithKey])) target[toResolveWithKey] = this // Always set with the lowest\n        })\n\n    }\n\n    // Local removal\n    remove = (from, to) => {\n        const fromInfo = this.#getPathInfo(from)\n        const toInfo = this.#getPathInfo(to)\n\n        const path = [fromInfo.absolute.value, toInfo.absolute.value]\n        const toRemove = [\n            { ref: this.active, path },\n            { ref: this.globals.active, path, unlisten: true }, // Remove subscription if required\n            // { ref: this.original, path: [toInfo.relative.value, fromInfo.relative.value] }, // Just removing from the list\n        ]\n\n\n        toRemove.forEach(o => {\n            const { ref, path, unlisten } = o\n\n            let base = ref[path[0]]\n\n            if (typeof base === 'object') {\n                delete base[path[1]] // complex listener\n                if (Object.keys(base).length === 0) {\n                    delete ref[path[0]]\n                    const sub = base[subscriptionKey]\n                    if (unlisten && sub) {\n                        this.context.monitor.remove(sub) // Cleaning up subscriptions (active only)\n                    }\n                    delete base[subscriptionKey]\n                }\n\n            } else delete ref[path[0]] // simple listener\n\n        })\n\n    }\n\n    // Local clearing\n    clear = (name) => {\n        const value = this.#getAbsolutePath(name)\n\n        Object.keys(this.active).forEach(from => {\n            Object.keys(this.active[from]).forEach(to => {\n                if (\n                    !value\n                    || from.slice(0, value.length) === value // Matches from\n                    || to.slice(0, value.length) === value // Matches to\n                ) this.remove(from, to)\n            })\n        })\n    }\n\n    has = (from, ref=this.active) => !!ref[from]\n\n    get = (from, ref=this.active) => ref[from]\n\n\n\n    // ----------------- Global Flow Activation Management -----------------\n    activate = (from, update) => {\n\n\n    const listenerGroups = [{\n        info: this.get(from, this.globals.active),\n        name\n    }]\n\n    listenerGroups.forEach(group => {\n\n        const info = group.info\n\n        if (info) {\n\n            if (info[listenerObject]) {\n\n                const tic = performance.now()\n\n                this.pass(from, {\n                    value: info.value,\n                    parent: this.active,\n                    key: group.name,\n                    subscription: info.subscription,\n                    __value: true\n                }, update)\n\n                const toc = performance.now()\n                globalThis.escomposePerformance.listeners.resolve.push(toc - tic)\n\n            } else if (typeof info === 'object') {\n\n                const tic = performance.now()\n\n                for (let key in info) {\n                    this.pass(from, {\n                        parent: info,\n                        key,\n                        subscription: info[key].subscription,\n                        value: info[key].value,\n                    }, update)\n\n                    const toc = performance.now()\n\n                    globalThis.escomposePerformance.listeners.resolve.push(toc - tic)\n\n                }\n            } else console.error('Improperly Formatted Listener', info)\n        }\n    })\n    \n}\n\npass = (from, target, update) => {\n\n    const id = this.context.id\n    const isValue = target?.__value\n    let parent = target.parent\n    let to = target.key\n\n\n    // const rootArr = root.split(this.context.options.keySeparator)\n    const info = target.parent[to]\n    target = info.value\n\n    let config = info?.[configKey] // Grab config\n\n    let ogValue = target\n    const type = typeof target\n\n    const checkIfSetter = (path, willSet) => {\n\n        const info = this.context.monitor.get(path, 'info')\n        if (info.exists) {\n            const val = info.value\n            const noDefault = typeof val !== 'function' && !val?.default\n            const value = (noDefault) ? toSet : val\n\n            const res = { value, bound: info.parent } // Ensure you have access to the bound parent\n\n            if (willSet) {\n                target = res.value\n                parent[to] = res\n            }\n\n            return res\n        } else return { value: undefined } //, root: undefined }\n\n    }\n\n    const transform = (willSet?) => {\n        const fullPath = [id]\n        // if (root) fullPath.push(...rootArr) // correcting for relative string\n        fullPath.push(...to.split(this.context.options.keySeparator))\n        return checkIfSetter(fullPath, willSet)\n    }\n\n    // ------------------ Grab Correct Target to Listen To ------------------\n\n\n    const getPathArray = (latest) => {\n        const path = [id]\n        const topPath: any[] = []\n        if (this.rootPath) topPath.push(...this.rootPath.split(this.context.options.keySeparator)) // correcting for relative string\n        topPath.push(...latest.split(this.context.options.keySeparator))\n        path.push(...topPath)\n        return path\n    }\n\n    // Confirmation of the target\n    if (typeof target === 'boolean') {\n        if (!isValue) transform(true)\n        else console.error(`Cannot use a boolean for ${specialKeys.listeners.value}...`)\n    }\n\n    // Name of the target\n    else if (type === 'string') {\n        const path = getPathArray(ogValue)\n        checkIfSetter(path, true)\n\n        if (isValue) {\n            parent[to] = { [ogValue]: parent[to] }\n            to = ogValue\n        }\n    }\n\n    else if (target && type === 'object') {\n\n        // Check if configuration object\n        const isConfig = isConfigObject(ogValue)\n\n        if (isConfig) {\n\n            if ('value' in ogValue) {\n                if (isValue) {\n                    target = parent[to] = ogValue.value // setting value\n                } else {\n                    target = parent[to].value = ogValue.value // setting value\n                }\n            } else transform(true)\n\n            if (ogValue){\n                if (ogValue) config = ogValue\n            }\n\n            Object.defineProperty(parent[to], configKey, { value: config })\n        }\n\n    }\n\n    // ------------------ Special Keywords ------------------\n    let isValidInput = true\n\n    if (config) {\n\n        \n        const bindKey = specialKeys.listeners.value\n        if (bindKey in config) {\n\n            // (de)Register listeners at runtime...\n            const path = getPathArray(config[bindKey].original ?? config[bindKey])\n            if (typeof config[bindKey] === 'string') {\n                const res = this.context.monitor.get(path)\n                if (!res)  target = `because ${path.slice(1).join(this.context.options.keySeparator)} does not point correctly to an existing component.`\n                else {\n                    config[bindKey] = {\n                        value: res,\n                        original: config[bindKey]\n                    }\n                }\n            } else if (!config[bindKey].value.__parent) {\n                target = `because ${config[bindKey].original ?? id.toString()} has become unparented.`\n            }\n\n        } \n        \n        else {\n\n            const branchKey = specialKeys.listeners.branch\n            const formatKey = specialKeys.listeners.format\n\n            if (branchKey in config) {\n\n                const isValid = config[branchKey].find(o => {\n\n                    let localValid: boolean[] = []\n                    if ('if' in o) localValid.push(o.if(update)) // Condition Function\n                    if ('is' in o) localValid.push(o.is === update) // Equality Check\n                    const isValidLocal = localValid.length > 0 && localValid.reduce((a, b) => a && b, true)\n\n                    if (isValidLocal) {\n                        if ('value' in o)  update = o.value // set first argument to branch value\n                    }\n\n                    return isValidLocal\n                })\n\n                if (!isValid) isValidInput = false\n            }\n\n\n            \n            // NOTE: May turn into an array here\n            if (formatKey in config) {\n                try {\n                    update = config[formatKey](update)\n                    if (update === undefined) isValidInput = false\n                } catch (e) { console.error('Failed to format arguments', e) }\n            }\n\n        }\n    }\n\n    // ------------------ Handle Target ------------------\n    if (\n        isValidInput // Ensure input is valid\n        && update !== undefined // Ensure input is not exactly undefined (though null is fine)\n    ) {\n\n        const arrayUpdate = Array.isArray(update) ? update : [update]\n\n\n        // Set New Value on Parent\n        if (target === toSet) {\n            const parentPath = [id]\n            // if (root) parentPath.push(...rootArr) // TODO: Check if this needs fixing\n            parentPath.push(...to.split(this.context.options.keySeparator))\n            const idx = parentPath.pop()\n            const info = this.context.monitor.get(parentPath, 'info')\n            if (info.value) info.value[idx] = update\n            else console.error(`Cannot set value on ${parentPath.filter(str => typeof str !== 'symbol').join(this.context.options.keySeparator)} from ${from}`)\n        }\n\n        // Direct Object with Default Function\n        else if (target?.default) {\n            target.default.call(target, ...arrayUpdate) // Call with parent context\n        }\n\n        // Direct Function\n        else if (typeof target === 'function') {\n\n            // const noContext = parent[to][listenerObject]\n            // if (noContext) \n            const boundTo = config?.[specialKeys.listeners.bind]?.value ?? info.bound ?? this.context.instance\n            if (boundTo) target.call(boundTo, ...arrayUpdate) // Call with top-level context\n            else target(...arrayUpdate) // Call with default context\n        }\n\n        // Failed\n        else {\n\n            let baseMessage = (to) ? `listener: ${from} \u2014> ${to}` : `listener from ${from}`\n            if (parent) {\n                console.warn(`Deleting ${baseMessage}`, target)\n                delete parent[to]\n            } else console.error(`Failed to add ${baseMessage}`, target)\n        }\n    }\n}\n\n\n}\n\nexport default Edgelord", "import { drillSimple, abortSymbol } from \"../common/drill\"\nimport { specialKeys } from \"../../spec/standards\"\n\ntype NestedRecord = {\n    name: string,\n    ref: any,\n    parent: any\n}\n\nexport const is = (key) => {\n    return key.includes(specialKeys.isGraphScript) || key === 'default'\n}\n\nconst basicObjects = ['Object', 'Array']\n\nexport const has = (o) => {\n    let has = false\n    drillSimple(o, (key, val, info) => {\n        if (info.path.length > 1){\n            const found = info.path.find(str => str === '__')\n            if (!found && is(key)) {\n                has = info.path\n                return abortSymbol\n            }\n        }\n    }, {\n\n        // Ignore graphscript root property and parents\n        ignore: ['__', '__parent'],\n\n        // Avoid drilling elements...\n        condition: (_, o) => {\n            const thisName = o?.constructor?.name\n            const propName = o?.__props?.constructor?.name\n            return (!basicObjects.includes(thisName) && !!globalThis[thisName]) || !!globalThis[propName] ? false : true\n        }\n    })\n\n    return has as false | string[]\n}\n\n// Get all nested components in an object by looking for graphscript properties\nexport function from (parent) {\n\n    if (!parent || typeof parent !== 'object') return null\n\n    let array = Object.entries(parent).map(([name,v]) => {\n        \n        const mayBeComponent = typeof parent === 'object' || typeof parent === 'function'\n\n        const hasGraphScriptProperties = !name.includes(specialKeys.isGraphScript) && (v && mayBeComponent) ? Object.keys(v).find(is) : false\n        if (hasGraphScriptProperties) {\n            return {\n                ref: v,\n                parent,\n                name\n            } as NestedRecord\n        }\n    }).filter((v) => v && v.ref) as NestedRecord[]\n    \n    let hasProperties = array.length > 0\n\n    // NOTE: This is an important feature to have if we don't keep the __children property\n    // This makes sure that nested components have graphscript properties\n    if (!hasProperties) {\n        const found = has(parent)\n        if (found) {\n            const sliced = found.slice(0, -2)\n            let target = parent\n            sliced.forEach(str=> {\n                target = target[str]\n                target.__ = true // Force recognition as a component\n            })\n            const name = found[0]\n            array = [{\n                ref: parent[name],\n                parent,\n                name\n            }]\n            hasProperties = true\n        }\n    }\n\n    if (hasProperties) return array\n    else return null\n}", "import { all } from \"../../../common/properties\"\nimport { isNativeClass } from \"../../../common/utils\"\n\nexport const name = 'props'\n\nexport const required = true\n\nexport const properties = {\n    dependents: ['__props']\n}\n\n\nlet originalPropKeys: string[]\n\nconst proxy = (target, source, props?, globalProxy = source) => {\n\n    if (!props) props = all(source)\n    props.forEach(str => {\n        if (!(str in target)) {\n\n            const desc = {\n                get: () => {\n                    return globalProxy[str]\n                },\n                set: (newVal) => {\n                    globalProxy[str] = newVal\n                },\n                enumerable: true,\n                configurable: false\n            }\n\n            // Double proxy this...\n            if (globalProxy !== source) Object.defineProperty(globalProxy, str, desc)\n\n            Object.defineProperty(target, str, desc)\n        }\n    })\n}\n\nconst propsLoader = ( esc ) => {\n\n    const val = esc.__props\n\n    let propsAdded: undefined | Object = undefined\n\n    Object.defineProperty(esc, '__props', {\n        get: () => {\n            return propsAdded\n        },\n        set: (newProps) => {\n\n            if (typeof newProps !== 'object' && !isNativeClass(newProps)) console.warn('Props must be an object')\n            else {\n\n                const props = all(newProps)\n                // Just set new properties as the props object\n                if (!propsAdded) {\n                    propsAdded = newProps\n                    originalPropKeys = props\n                }\n\n                // Create a proxy props object if set multiple times\n                else {\n                    const ogProps = propsAdded\n                    propsAdded = {}\n                    proxy(propsAdded, ogProps, originalPropKeys)\n                }\n\n                proxy(esc, newProps, props, propsAdded)\n            }\n        },\n        enumerable: false,\n        configurable: false\n    })    \n\n    if (val) esc.__props = val\n\n    return esc\n}\n\n\nexport default propsLoader", "import { ESComponent } from \"../../../../spec\"\nimport { specialKeys } from \"../../../../spec/standards\"\nimport pathLoader from \"./path\"\n\nexport const name = 'parent'\n\nexport const required = true\n\nexport const properties = {\n    dependencies: [\n        specialKeys.isGraphScript,\n    ],\n    dependents: [] // Creates path\n}\n\nconst parentLoader = (esc, toApply, options) => {\n\n    const configuration = esc[specialKeys.isGraphScript]\n\n    configuration.parent = {\n        callbacks: [],\n        add: function (callback) {\n            this.callbacks.push(callback)\n        },\n        get: () => {\n            return parent\n        }\n    }\n\n    const existingParent = esc[specialKeys.parent] ?? toApply[specialKeys.parent]\n\n    let parent = existingParent as ESComponent\n    Object.defineProperty(esc, specialKeys.parent, {\n        get: () => {\n            return configuration.parent.get()\n        },\n        set: (newParent) => {\n\n            const disconnecting = parent && !newParent\n\n            if (parent?.[specialKeys.isGraphScript]) {\n                const name = configuration.name\n                delete parent[name] // Delete...\n                parent.__.components.delete(name) // Delete...\n            }\n\n            parent = newParent\n\n            if (parent?.[specialKeys.isGraphScript]) {\n                const name = configuration.name\n                if (parent[name]) console.error('OVERWRITING EXISTING PROPERTY ON PARENT!')\n                parent[name] = esc // Add...\n                parent.__.components.set(name, esc) // Add...\n            }\n\n            configuration.parent.callbacks.forEach(callback => callback.call(esc, newParent))\n\n            // Update path\n            pathLoader(esc, undefined, options) // update path\n\n            // if (v instanceof HTMLElement) {\n            \n            // Signal disconnection (which isn't simply being a root Component)\n            if (disconnecting) {\n                esc[specialKeys.isGraphScript].stop.run() // Try running start\n            }\n            \n            // Signal Connection\n            else if (parent) { \n                const isConnected = configuration.connected\n                const toConnect = isConnected instanceof Function\n                esc[specialKeys.isGraphScript].start.run() // Try running start\n                if (toConnect) isConnected() // Signal connection to the DOM\n            }\n            // }\n\n\n            // configuration.graph\n        }\n    })    \n\n    pathLoader(esc, undefined, options) // update path\n\n}\n\n\nexport default parentLoader", "import { Options } from \"../../../../common/types\"\nimport { specialKeys } from \"../../../../../spec/standards\"\nimport { isNode } from \"../../../../common/globals\"\n\nexport const name = 'path'\n\nexport const required = true\n\nexport const properties = {\n    dependencies: [\n        specialKeys.isGraphScript,\n        specialKeys.parent,\n    ],\n    dependents: []\n}\n\nconst pathLoader = ( esc, _, opts: Partial<Options>={}) => {\n\n    // Specify the current path of the object        \n    const configuration = esc[specialKeys.isGraphScript]\n    let parent = esc[specialKeys.parent]\n    const name = configuration.name // Grab name from the configuration\n\n    parent = ( (!isNode && parent instanceof Element) ? parent?.[specialKeys.component] : parent) ?? esc[specialKeys.parent]\n\n    const isESC = { value: '', writable: true } as any\n\n    if (parent) {\n        const parentComponentConfiguration = parent[specialKeys.isGraphScript]\n            \n        if (parentComponentConfiguration){\n            if (typeof name === 'string') {\n                let target = parent\n                const path: string[] = []\n                while (target && target[specialKeys.isGraphScript]) {\n                    const parentName = target[specialKeys.isGraphScript].name\n                    if (typeof parentName === 'string') path.push(parentName)\n                    else {\n                        if (typeof parentName === 'symbol') configuration.root = parentName\n                        else console.error('No graph reset occured for', parentName)\n                        break\n                    }\n                    target = target[specialKeys.parent]\n                }\n                isESC.value = [...path.reverse(), name]\n                isESC.value = isESC.value.join(opts.keySeparator ?? '.')\n            }\n        }\n    }\n\n    Object.defineProperty(configuration, 'path', isESC)    \n}\n\n\nexport default pathLoader", "import create from \"./index\"\nimport { isNativeClass, resolve } from '../common/utils/index'\nimport { all } from \"../common/properties\"\nimport { defaultProperties, keySeparator, specialKeys } from \"../../spec/standards\"\nimport parse from \"./parse\"\nimport { ApplyOptions, Loaders, SortedLoaders } from \"./types\"\nimport { toReturn } from \"./symbols\"\nimport { ESComponent } from \"../../spec\"\nimport FlowManager from \"./edgelord/index\"\n\nimport * as components from \"./components\"\n\n// Native Loaders\nimport * as propsLoader from \"./loaders/props\"\nimport * as parentLoader from \"./loaders/parent\"\n\n\n\n\nconst run = (f, context, args, x?) => resolve(x, () => f.call(context, ...args))\n\nconst runSequentially = (callbacks: Function[], args: any[] = [], context?) => {\n    if (callbacks.length) {\n        if (callbacks.length === 1) run(callbacks[0], context, args)\n        else return callbacks.reduce((x,f) => run(f, context, args, x))\n    }\n\n}\n\nconst compose = (callbacks, start, otherArgs: any[] = [], toIgnore: Function) => {\n    return callbacks.reduce(\n        (x, f) => resolve(x, (res) => {\n            let func = (typeof f === 'function') ? f : f.default\n            const output = func(res, ...otherArgs)\n            return (toIgnore && toIgnore(output)) ? res : output\n        }),\n        start\n    )\n}\n\n// Use a function composition technique run the loaders in order\nconst runLoaders = (loaders: Loaders | SortedLoaders, inputs: {\n    main: any,\n    overrides?: any,\n    options?: any\n}, which?) => {\n\n    const { main, overrides, options } = inputs\n\n\n    let preloaded: Loaders | undefined;\n    if (!Array.isArray(loaders)) {\n        if (!loaders[which]) return main\n        const sorted = loaders as SortedLoaders\n        loaders = sorted[which] ?? []\n        switch (which) {\n            case 'activate':\n                preloaded = [...sorted.load ?? []]\n                break\n            case 'start':\n                preloaded = [...sorted.load ?? [], ...sorted.activate ?? []]\n            case 'stop':\n                preloaded = [...sorted.load ?? [], ...sorted.activate ?? [], ...sorted.start ?? []]\n                break\n        }\n    }\n\n    const resolvedLoaders = loaders as Loaders\n\n    const loadersToUse = filterLoaders(main, resolvedLoaders, preloaded) // Check which loaders are needed\n\n    if (loadersToUse) return compose(loadersToUse, main, [overrides, options], (output) => !output || typeof output !== 'object')\n    else return main\n}\nconst sortLoaders = (loaders: Loaders) => {\n    const sorted: Partial<SortedLoaders> = {}\n    loaders.forEach(o => {\n        const behavior = (typeof o === 'function') ? 'activate' : o.behavior ?? 'activate'\n        const theseLoaders = sorted[behavior] = sorted[behavior] ?? []\n        theseLoaders.push(o)\n    })\n\n    return sorted as SortedLoaders\n\n}\n\n// TODO: Add a way to move this after the composition loader.\n// This will require defining specific keys on the loaders object to determine the order of execution\n\nconst filterLoaders = (esc, loaders: Loaders, beenLoaded: Loaders = []) => {\n\n    const keys = all(esc).filter(str => str.slice(0, 2) === '__') // Grab used keys\n\n    const defaultPropertiesCopy = Object.values(defaultProperties)\n    const created = [...defaultPropertiesCopy, ...beenLoaded.map(o => {\n        if (typeof o === 'function') return []\n        else return o.properties.dependents\n    }).flat()] // Assume these are created\n\n    const usedLoaders = loaders.filter(o => {\n        if (o && typeof o === 'object') {\n            const name = o.name\n            const { dependencies, dependents = [] } = o.properties\n            let include = o.required || !dependencies\n            if (!include && dependencies) {\n                const optionalNameMessage = name ? ` (${name})` : ''\n                const found = dependents.find(key => keys.includes(key))\n                if (found) {\n                    const deps = {}\n                    dependencies.forEach((key) => deps[key] = created.includes(key))\n                    const missingDependency = dependencies.filter((key) => !created.includes(key))\n                    if (missingDependency.length) console.warn(`The loader${optionalNameMessage} for ${dependencies.join(', ')} might be loaded too early, since we are missing the following dependencies: ${missingDependency.join(', ')}`)\n                    include = true\n                }\n                // else console.warn(`Ignoring the loader${optionalNameMessage ?? ` for: ${dependencies.join(', ')}`}`)\n            }\n\n            if (include && dependents) created.push(...dependents)\n\n            return include\n        }\n    })\n\n    return usedLoaders\n}\n\nfunction addCallback(callback, priority: 'before' | 'after' | 'main' = 'main') {\n    const { callbacks } = this\n    callbacks[priority].push(callback)\n    return true\n}\n\nfunction runRecursive(resolved) {\n    const { callbacks, name } = this\n\n\n    if (!this.value) {\n\n        const isStop = name === 'stop'\n        const configuration = resolved[specialKeys.isGraphScript]\n\n        const callback = isStop ? configuration.stop.initial : resolved[specialKeys[name]]\n        this.value = true\n\n\n        if (!isStop) configuration.stop.value = false\n\n        const toCall = (callback && !isStop) ? [...callbacks.before, callback, ...callbacks.main] : [...callbacks.before, ...callbacks.main]\n\n        const result = runSequentially(toCall, [resolved], resolved)\n        return resolve(result, () => {\n\n            const hierarchy = Array.from(resolved[specialKeys.isGraphScript].components.entries()) as [string, ESComponent][]\n\n            // Initialize Nested Components (and wait for them to be done)\n            const ranOnChildren = resolve(hierarchy.map(async ([tag, component]) => {\n                const promise = component[specialKeys.promise]\n                if (promise && typeof promise.then === 'function') component = hierarchy[tag] = await promise // Wait for the component to be ready\n\n                return await component[specialKeys.isGraphScript][name].run() // Run the component start / stop function\n            }))\n\n            return resolve(ranOnChildren, () => {\n\n                // After All Components Resolved\n                const result = runSequentially(callbacks.after, [resolved], resolved)\n                return resolve(result, () => {\n\n                    // Call Final Function or Return\n                    if (isStop) {\n                        if (callback) callback.call(resolved, resolved) // Run general stop function last\n\n                        // Clear all listeners below esc node\n                        configuration.flow.clear()\n\n                        // Clear all listeners above the Component that reference it\n                        const path = resolved[specialKeys.isGraphScript].path\n                        let target = resolved\n                        const parent = target[specialKeys.parent]\n                        while (parent && parent[specialKeys.isGraphScript] !== undefined) {\n                            const res = target[specialKeys.parent] // parent is a component\n                            if (res) {\n                                target = res\n                                if (target) {\n                                    const configuration = target[specialKeys.isGraphScript]\n                                    if (configuration) configuration.flow.clear(path)\n                                }\n                            } else break\n                        }\n\n\n\n                        configuration.start.value = false // Can be restarted\n                    }\n\n                    return true\n                })\n            })\n        })\n    }\n}\n\n\nexport default function load(esc, loaders: Loaders = [], options: ApplyOptions): ESComponent {\n    \n    const tic = performance.now()\n\n\n    const parent = options.parent // Don't proxy the window...\n    const {\n        parentObject,\n        toApply = {},\n        callbacks = {},\n        opts = {},\n        name = Symbol('root'), // Create symbol to identify the root instance\n    } = options as ApplyOptions\n\n    // Track the original component structure\n    const original = esc\n\n\n    // Parse the configuration object into a final configuration object\n    esc = parse(esc, toApply, opts)\n\n    // Shortcut to return an existing (but updated) component\n    if (esc[toReturn]) return esc[toReturn] \n\n    // Return bulk operation requests\n    if (Array.isArray(esc)) return resolve(esc.map(o => load(o, loaders, options)))\n\n    // Create root property\n    esc[specialKeys.isGraphScript] = createGraphScriptRoot(name, options, { parent, original, loaders })\n\n    const sortedLoaders = sortLoaders(loaders)\n    const loaded = runLoaders(sortedLoaders, { main: esc, overrides: toApply, options: opts }, 'load') // Complete component resolution\n\n    const component = resolve(loaded, loaded => {\n\n        // Parent Loader\n        let toApplyParent = (!loaded[specialKeys.parent] && parent) ? { [specialKeys.parent]: parent } : {}\n        const parented = runLoaders([parentLoader], { main: loaded, overrides: toApplyParent, options: opts }) // Use original parent here (in case none are specified later)\n\n        // Props Loader\n        const propped = runLoaders([propsLoader], { main: parented }) // Use original parent here (in case none are specified later)\n\n\n        const res = runLoaders(sortedLoaders, { main: propped, overrides: toApply, options: opts }, 'activate') // Recognize all special keys\n\n        return resolve(res, (esc) => {\n\n            esc.__.ref = esc\n\n            // -------- Set Resolved Component --------\n            if (parentObject) parentObject[name] = esc // setting immediately\n\n            // On Creation Callbacks\n            if (typeof name === 'symbol' && callbacks.onRootCreated) callbacks.onRootCreated(name, esc)\n            if (callbacks.onInstanceCreated) callbacks.onInstanceCreated(esc.__.path, esc)\n\n            const configuration = esc[specialKeys.isGraphScript]\n\n            // Resolve Nested Components\n        const nested = components.from(propped)\n\n        const promises = (nested) ? nested.map((info) => {\n            const copy = Object.assign({}, options)\n            const name = copy.name = info.name\n            delete copy.toApply // Only apply to the root node\n            copy.parentObject = info.parent\n            copy.parent = esc\n\n            const ref = info.ref\n\n            // TODO: Reinstate the ability to define child position on the node (in case it is confused...)\n            if (ref) {\n\n                // Existing ES Component (reparent)\n                if (ref.__?.symbol) {\n                    const parent = ref.__.parent\n                    if (parent) console.error(`Changing parent of existing component (${ref.__.path}) from ${parent.__.path} to ${configuration.path}`)\n                    ref.__parent = esc\n                    esc[specialKeys.isGraphScript].components.set(name, res)\n                } \n                \n                // New Component Template (load)\n                else {\n                    const resolution = load(ref, loaders, copy) // Apply loaders to nested components\n\n                    // Allow users to await the resolution of all children\n                    Object.defineProperty(info.parent[name], specialKeys.promise, { value: resolution, writable: false, })\n\n                    const promise = resolve(resolution, (res) => {\n                        configuration.components.set(name, res)\n                        return res\n                    })\n\n                    configuration.components.set(name, promise)\n                }\n            } else {\n                delete info.parent[name]\n                console.error('No reference found for nested component', info)\n            }\n        }) : []\n\n            // Allow the user to wait until all the chidren are resolved by awaiting the promise\n            let isResolved\n            const resolvePromise = new Promise(resolve => isResolved = async () => {\n                configuration.resolved = true\n                resolve(true)\n            })\n\n            Object.defineProperty(esc, `${specialKeys.resolved}`, { value: resolvePromise })\n            configuration.resolved = false // To resolve the promise\n\n            // Signal that the component is ready\n            resolve(promises, () => isReady(esc, callbacks, isResolved))\n\n            // Return the esc object\n            return esc\n        })\n    })\n\n    // Track Performance\n    const creationToc = performance.now()\n    const toCreateTime = creationToc - tic\n\n    resolve(component, (esc) => {\n        if (!Array.isArray(esc)) {\n            const resolveToc = performance.now()\n            const resolveTime = resolveToc - tic\n            resolve(esc.__resolved, () => {\n                const toc = performance.now()\n                const resolveAllTime = toc - tic\n                globalThis.escomposePerformance.resolve.push(resolveTime)\n                globalThis.escomposePerformance.resolveAll.push(resolveAllTime)\n                globalThis.escomposePerformance.create.push(toCreateTime)\n\n            })\n        }\n    })\n\n    // Return the resolved component\n    return component\n}\n\nfunction createGraphScriptRoot(name, options, additionalInfo: any = {}) {\n\n    const { parent, original, loaders } = additionalInfo\n\n    const isSymbol = typeof name === 'symbol'\n\n    // Specify the current path of the object\n    const parentId = parent?.[specialKeys.isGraphScript].path\n    const path = (parentId) ? [parentId, name] : ((typeof name === 'string') ? [name] : [])\n    const absolutePath = path.join(options.keySeparator ?? keySeparator)\n\n        \n    const __ = {\n\n        // ---------- Identifiers ----------\n        name,\n        symbol: Symbol('isGraphScript'), // A unique value to compare against\n\n        // ---------- Relative Position ----------\n        root: isSymbol ? name : parent[specialKeys.isGraphScript].root, // Set graph property\n        path: absolutePath, // Temporary Path Property\n\n        // ---------- Instantiation Options ----------\n        options,\n\n        // ----------Original Instantiation Configuration Object ----------\n        original,\n\n        // ---------- Loader State Tracker ----------\n        // TODO: Make sure the loaders are using this so it can be tracked!\n        states: {},\n\n        // ---------- Nested Components Map ----------\n        components: new Map(),\n        connected: false,\n        resolved: false,\n\n        // ---------- Listener Managers ----------\n        flow: new FlowManager(),\n\n        // ---------- Creation Managers ----------\n        create: (esc) => {\n            if (!options.loaders) options.loaders = loaders // re-apply loaders to the options\n            return create(esc, undefined, options)\n        },\n\n        // ---------- Lifecycle Managers ----------\n        stop: {\n            name: 'stop',\n            value: false,\n            add: addCallback,\n            callbacks: {\n                before: [],\n                main: [],\n                after: [],\n            },\n        },\n\n        start: {\n            name: 'start',\n            value: false,\n            add: addCallback,\n            callbacks: {\n                before: [],\n                main: [],\n                after: [],\n            },\n        },\n\n    } as ESComponent['__']\n\n    const toRunProxy = function () { return runRecursive.call(this, __.ref) }\n    __.start.run = toRunProxy.bind(__.start)\n    __.stop.run = toRunProxy.bind(__.stop)\n\n    return __\n}\n\n    // On Ready Callback\n    function isReady (esc, callbacks, isResolved) {\n\n        const configuration = esc[specialKeys.isGraphScript]\n\n        // -------- Bind Functions to Node --------\n        for (let key in esc) {\n            const og = esc[key]\n            if (typeof og === 'function' && !isNativeClass(og)) {\n                const context = esc[specialKeys.proxy] ?? esc\n                // const og = esc[key]\n                esc[key] = og.bind(context)\n            }\n        }\n\n        // Add Stop Method\n        configuration.stop.initial = esc[specialKeys.stop]\n        esc[specialKeys.stop] = configuration.stop.run\n\n\n        // Ensure all GraphScript properties are non-enumerable\n        // And bind all functions to the node\n        const keys = all(esc)\n\n        for (let key of keys) {\n            if (components.is(key)) {\n                const desc = Object.getOwnPropertyDescriptor(esc, key)\n                if (desc?.enumerable) Object.defineProperty(esc, key, { ...desc, enumerable: false })\n            }\n\n            // if (typeof esc[key] === 'function') esc[key] = esc[key].bind(esc) // ensure all functions are bound to the node\n        }\n\n        // Trigger Parent / Path Loader\n        const finalParent = esc[specialKeys.parent]\n        esc[specialKeys.parent] = finalParent\n\n        if (callbacks.onInstanceReady) callbacks.onInstanceReady(esc.__.path, esc)\n\n        isResolved()\n    }", "import Monitor from \"../esmonitor/src/index\"\nimport { deep as deepClone } from \"../common/clone.js\"\nimport { Options } from \"../common/types\"\nimport * as utils from \"../common/utils\"\n\nimport { parseOptions } from \"./parse\"\nimport { ConfigInput } from \"./types\"\nimport load from \"./load\"\n\nimport * as components from \"./components\"\n\nimport { specialKeys } from \"../../spec/standards\"\nimport { ESComponent } from \"../../spec/index\"\n\nimport './globals'\n\n// Use a global monitor instance to listen to an object property without creating an ES Component \nexport const monitor = new Monitor()\n\n// This function is the user interface for creating ES Components\nexport const create = (\n    config: ConfigInput, // This is a configuration object, which can be many things\n    toApply: any = {}, // This is an object that is applied to resulting objects from the configuration object\n    options: Partial<Options> = {}, // There are a few options that the user can set to configure their Components\n) => {\n\n    // Parse the options object into a final options object\n    const fullOptions = parseOptions(options)\n\n    const callbacks = {\n\n        onRootCreated: (id, esc) => (fullOptions.monitor as Monitor).set(id, esc, fullOptions.listeners), // Setting root instance\n\n        onInstanceCreated: (absolutePath, esc) => {\n\n            // Set listeners as soon as possible\n            if (fullOptions.listen !== false) {\n                const to = esc[specialKeys.listeners.value] ?? {}  // Uses to \u2014> from syntax | Always set\n\n                const flow = esc[specialKeys.isGraphScript].flow\n                flow.setInitialProperties(to, absolutePath, {\n                    id: esc[specialKeys.isGraphScript].root, // NOTE: Make sure this can change with the root\n                    monitor: fullOptions.monitor,\n                    options: fullOptions\n                })\n\n                esc[specialKeys.listeners.value] = to // Replace with listeners assigned (in case of unassigned)\n\n\n                // -------- Trigger Execution when Ready --------\n                if (specialKeys.trigger in esc) {\n                    if (!Array.isArray(esc[specialKeys.trigger])) esc[specialKeys.trigger] = []\n                    const args = esc[specialKeys.trigger]\n                    flow.onStart(() => esc.default(...args))\n                    delete esc[specialKeys.trigger]\n                }\n            }\n        },\n\n        // Activate listeners when instance is ready\n        onInstanceReady: (absolutePath, esc) => esc[specialKeys.isGraphScript].flow.start(),\n    }\n\n    const loaders = fullOptions.loaders\n    const component = load(config, loaders, {\n        toApply,\n        opts: fullOptions,\n        callbacks,\n        waitForChildren: false\n    })\n\n    return utils.resolve(component, (esc) => {\n        const isArray = Array.isArray(esc)\n        let arr = (!isArray) ? [esc] : esc\n        arr.map(esc => {\n            if (\n                esc[specialKeys.parent] // Must have a parent to be active\n                || esc.__.path === ''   // OR be the root\n            ) {\n                const configuration = esc[specialKeys.isGraphScript]\n                const hasStarted = configuration.start.value\n                if (hasStarted === false) {\n                    const onRun = configuration.start.run()\n                    return utils.resolve(onRun, resolve) // Return synchronously unless the user requests a promise\n                }\n\n            } else return esc // Just return instance synchronously since the component is only activated when placed in the DOM\n        })\n\n        if (!isArray) return arr[0] as ESComponent\n        else return arr as ESComponent[]\n    }) as ESComponent\n\n}\n\nexport default create\n\n\n// Find components on an object\nexport const find = components.from\n\n// Apply a callback to promises and direct references\nexport const resolve = utils.resolve\n\n// Deep clone an object without creating an ES Component\nexport const clone = deepClone\n\n// Merge two objects together without creating an ES Component \nexport const merge = (objects, updateOriginal) => {\n    let base = objects.shift()\n    objects.forEach(o => base = utils.merge(base, o, updateOriginal))\n    return base\n}\n", "import { log } from '../../utils'\n\nexport const __ = true\n\nexport const x = 5\nexport const y = 2\n\nexport const jump = () => {\n    const message = `jump!`\n    log.add(message)\n    return 'jumped!'; \n}\n\n// //listeners in a scope are bound to 'this' node\n// export const __listeners = {\n//     'nodeB.nodeC':function(op_result){\n//         const message = 'nodeA listener: nodeC operator returned:'\n//         log.add(message)\n//     },\n//     'nodeB.nodeC.z':function(newZ){\n//         const message = 'nodeA listener: nodeC z prop changed:'\n//         log.add(message)\n//     },\n\n//     // ---------- Equivalent Decarations ----------\n//     // From \u2014> To\n//     // 'nodeB.x':'jump',\n//     // 'nodeE': 'jump',\n\n//     // To \u2014> From\n//     'jump': {\n//         'nodeE': true,\n//         'nodeB.x': true\n//     }\n// }", "\nexport const isNode = typeof process === 'object'\n\nconst elId = `escomposeOperationsManagerLog`\n\nif (!isNode) {\n    const ol = document.createElement('ol')\n    ol.id = elId\n    document.body.appendChild(ol)\n\n    const style = document.createElement('style')\n    style.innerText = `\n        ol {\n            position: absolute;\n            top: 0;\n            right: 0;\n            font-size: small;\n            margin: 0;\n            padding: 0;\n            background-color: rgba(255, 255, 255, 0.8);\n            padding: 10px;\n            overflow: scroll;\n            height: 100vh;\n        }\n\n        li {\n            margin-left: 25px;\n        }\n    `\n    document.body.appendChild(style)\n}\n\n// Maintain a list of the active states\nexport const log = {\n    element: (isNode) ? undefined : document.getElementById(elId),\n    add: function (message) {\n        if (this.element) {\n            var li = document.createElement('li');\n            li.innerText = message;\n            this.element.appendChild(li);\n        } else console.log(message)\n    },\n    addCommand: function (message) {\n\n        console.log(`--------- ${message} ---------`)\n        if (this.element) {\n            var li = document.createElement('div');\n            li.innerText = message;\n            li.style.fontWeight = 'bold';\n            this.element.appendChild(li);\n        }\n    },\n    addHeader: function (message) {\n        console.log(`********* ${message} *********`)\n        if (this.element) {\n            var li = document.createElement('h3');\n            li.innerText = message;\n            this.element.appendChild(li);\n        }\n    },\n}\n\n\nexport type OperationsType = (Function | {\n    function: Function,\n    name?: string,\n    header?: string,\n    ignore?: boolean\n})[]\n\nexport type OperationsStart = Function\n\n\nexport type OperationsConfig = {\n    operations?: OperationsType,\n    start?: OperationsStart\n}\n\n\nexport class OperationsManager {\n\n    operations: OperationsType = []\n\n    log = log\n    \n    step = 0\n    #iterations = 0\n    get iterations () {\n        return this.#iterations\n    }\n\n    set iterations (val) {\n        this.#iterations = val\n        this.step = this.#iterations % this.operations.length\n    }\n    \n    startFunction?: OperationsStart\n    started = false\n\n    returned: any = {}\n\n    constructor(config: OperationsConfig = {}){\n        this.set(config)\n        // globalThis.onkeydown = (ev) => {\n        //     const key = ev.key\n        //     if (key === 'Enter') this.next()\n        //     else if (key === ' ') this.runAll()\n        // }\n    }\n\n    set(config: OperationsConfig = {}){\n        if ('start' in config) this.setStart(config.start)\n        if ('operations' in config) this.setOperations(config.operations)\n    }\n\n\n    start = (...args) => {\n        if (this.started) {\n            console.warn('Already started...')\n            return this.returned\n        } else {\n            this.started = true\n            if (this.startFunction)  {\n                this.returned = this.startFunction.call(this, ...args)\n                return this.returned\n            }\n        }\n    }\n\n    setStart(start){\n        this.started = false\n        this.startFunction = start\n    }\n\n    setOperations(operations: OperationsType = []) {\n        this.operations = operations\n    }\n\n\n    runAll = () => {\n        if (this.step === 0) this.next()\n\n        let count = 0\n        while (this.step > 0) {\n            count++\n            this.next()\n        }\n    }\n\n    run = (command) => {\n        if (!this.started) this.start()\n\n        if (typeof command === 'function') command = {\n            function: command,\n            name: command.name\n        }\n\n        if (command) {\n            if (command.ignore) return\n            else {\n                if (command.header) log.addHeader(command.header)\n                if (command.name) log.addCommand(command.name)\n                return command.function.call(this)\n            }\n        }\n    }\n\n    next = () => {\n        const res = this.run(this.operations[this.step])\n        this.iterations++\n        return res\n    }\n}", "import * as nodeA from './nodes/nodeA.js'\nimport { log } from '../utils'\n\nconst nodeAInstance = Object.assign({}, nodeA)\n\n\nconst shared = {\n    value: 0,\n}\n\nlet value = 0\n\nfunction defaultFunction () {\n    const originalType = typeof this.__.original\n    const message = `instanced node (${this.__.name} ${originalType === 'function' ? 'class ' : originalType}) called! ${this.shared.value} ${this.mystery.value}`\n    this.shared.value++\n    this.mystery.value++\n    log.add(message)\n}\n\nclass nodeClass { //treated as a class to instance rather than a function to set as default\n    \n    static __ = true\n    \n    shared = shared\n\n    mystery = {\n        value\n    }\n\n    default = defaultFunction\n}\n\nconst objectNotClass = {\n    shared: shared,\n\n    mystery: {\n        value\n    },\n\n    default: defaultFunction\n}\n\nconst nodeD = (...args)=>{ return args.reduce((a,b) => a + b, 0); }\n// nodeD.__ = true\n\nlet tree = {\n\n    nodeA: nodeAInstance,\n\n    nodeB:{\n        __: true, // Artificially trigger as a node\n        x:3,\n        y:4,\n        nodeC:{\n            z:4,\n            default:function(a) { \n                this.z += a; \n                const message = 'nodeC operator: nodeC z prop added to'\n                log.add(message)\n                return this.z; \n            },\n            // __listeners:{\n            //     'nodeA.x':function() { \n            //         const message = 'nodeC listener: nodeA x prop updated'\n            //         log.add(message)\n            //     },\n            //     'nodeA.jump':function() { \n            //         const message = 'nodeC listener: nodeA '\n            //         log.add(message)\n            //     }\n            // }\n        }\n        \n    },\n\n    nodeD: nodeD, //becomes the .default prop and calling triggers setState for this tag (or nested tag if a child)\n\n\n    nodeE:{\n        __animate: 1,\n        default:function (){\n            const message = 'looped'\n            log.add(message)\n            return true;\n        },\n    },\n\n    nodeF:{\n        __props: document.createElement('div'), //properties on the '__props' object will be proxied and mutatable as 'this' on the node. E.g. for representing HTML elements\n        __onconnected:function (node) { \n            this.innerHTML = 'Test';\n            this.style.backgroundColor = 'green'; \n            document.body.appendChild(this.__props); \n        },\n        __ondisconnected:function(node) {\n            document.body.removeChild(this.__props);\n        }\n        \n    },\n\n    nodeG: nodeClass,\n\n    nodeH: nodeClass,\n\n    nodeI: objectNotClass,\n\n    // Global Listeners\n    // TODO: Allow for bound implementations of global listeners\n    __listeners: {\n        'nodeD':function(res){\n            const message = 'nodeD operator returned: ' + res\n            log.add(message)\n        },\n        'nodeB.nodeC':function(op_result){\n            const message = 'nodeA listener: nodeC operator returned:'\n            log.add(message)\n        },\n        'nodeB.nodeC.z':function(newZ){\n            const message = 'nodeA listener: nodeC z prop changed:'\n            log.add(message)\n        },\n    \n        // ---------- Equivalent Decarations ----------\n        // From \u2014> To\n        // 'nodeB.x':'jump',\n        // 'nodeE': 'jump',\n    \n        // To \u2014> From\n        'nodeA.jump': {\n            'nodeE': true,\n            'nodeB.x': true\n        },\n\n        '': {\n            'nodeA.jump': function() { \n                const message = 'nodeC listener: nodeA '\n                log.add(message)\n            },\n        }\n    }\n\n};\n\nexport default tree", "import { specialKeys } from \"../../spec/standards\"\n\nconst animations = {}\n\n\nexport const name = 'animate'\n\nconst key = specialKeys.animate\n\nexport const properties = {\n    dependents: [specialKeys.animate]\n}\n\nexport default function animate(esc) {\n\n    \n    if (esc[key]) {\n\n        let original = esc[key]\n\n        const id = Math.random()\n        const interval = (typeof original === 'number') ? original : 'global'\n\n\n        let startFunction;\n\n        if (!animations[interval]) {\n        \n            const info = animations[interval] = {objects: {[id]: esc}} as any\n\n            const objects = info.objects\n            const runFuncs = () => {\n                for (let key in objects) objects[key].default()\n            }\n\n            // Global Animation Frames\n            if (interval === 'global') {\n                const callback = () => {\n                    runFuncs()\n                    info.id = window.requestAnimationFrame(callback)\n                }\n\n                startFunction = callback\n\n                animations[interval].stop = () => {\n                    window.cancelAnimationFrame(info.id)\n                    info.cancel = true\n                }\n            }\n            // Set Interval\n            else {\n                startFunction = () => {\n                    runFuncs() // run initially\n                    info.id = setInterval(() => runFuncs(), 1000/interval)\n                }\n\n                animations[interval].stop = () => clearInterval(info.id)\n            } \n        } \n        \n        // Add to Objects\n        else {\n            startFunction = () => {\n                esc.default() // run initially\n                animations[interval].objects[id] = esc\n            }\n        }\n\n        esc[specialKeys.isGraphScript].start.add(startFunction)\n\n        // Stop Animation\n        esc[specialKeys.isGraphScript].stop.add(() => {\n            delete animations[interval].objects[id]\n            esc[key] = original // Replace with original function\n            if (Object.keys(animations[interval].objects).length === 0) {\n                animations[interval].stop()\n                delete animations[interval]\n            }\n        })\n    }\n}", "\n// import { component } from \"../../core/component2\";\n// import { loaders } from \"../../core/loaders\";\nimport tree from './tree'\nimport * as core from '../../packages/core/index';\nimport * as animate from '../../packages/escode-animate-loader';\n\nconst nodeAInstance = tree.nodeA // Original value for nodeA\n\nlet component, secondComponent, popped;\nconst options = {\n    loaders: [animate]\n}\n\n\nexport const model = tree\n\nexport function start () {\n    component = core.create(tree, {}, options)\n\n    this.log.addHeader('Created component')\n    console.log('Component:', component);\n\n    // Stop animating after a few seconds\n    setTimeout(()=>{ \n        component.nodeE.__parent = null // Remove from parent\n        this.log.addCommand('nodeE removed!')\n    },5500)\n}\n\nexport const operations = [\n    {\n        name: 'component.run(\"nodeD\")',\n        function: () => {\n            component.nodeD(); // Can be listened to\u2014but isn't a 'true' component\n        },\n    },\n    {\n        name: 'component.run(\"nodeG\")',\n        function: () => {\n            component.nodeG.default(); // Has been instantiated because of the static __ property\n            component.nodeH.default();\n            component.nodeI.default();\n            component.nodeG.default(); // Has been instantiated because of the static __ property\n        },\n    },\n    {\n        name: 'nodeAInstance.x = 1',\n        function: () => {\n            console.log('Node Instance', nodeAInstance, tree)\n            nodeAInstance.x = 1; //should trigger nodeA.x listener on nodeC\n        },\n    },\n    {\n        name: `component.get('nodeA').x = 2`,\n        function: () => {\n            component.nodeA.x = 2; //same thing\n        },\n    },\n    {\n        name: `component.get('nodeB').x += 1`,\n        function: () => {\n            component.nodeB.x += 1; //should trigger nodeA listener jump()\n\n        },\n    },\n    {\n        header: `Clear All Listeners`,\n        ignore: true,\n        function: () => {\n            component.__.flow.clear() // NEW FEATURE: Clear all listeners\n        }\n    },\n    {\n        name: `component.run('nodeB.nodeC', 4)`,\n        function: () => {\n            component.nodeB.nodeC.default(4)\n        },\n    },\n    {\n        name: `component.get('nodeB.nodeC').z += 1`,\n        function: () => {\n            component.nodeB.nodeC.z += 1\n        },\n    }, \n    {\n        name: `component.get('nodeA').jump()`,\n        function: () => {\n            component.nodeA.jump()  //should trigger nodeC listener\n        }, \n    },\n\n    // TODO: Need to reimplement unsubscribe functions\n    {\n        header: `Unsubscribe nodeB.nodeC from nodeA.jump`,\n        ignore: true,\n        function: () => {\n            // NEW FEATURE: Clearing nodeC listener from nodeA.jump\n            component.__.flow.unsubscribe('nodeB.nodeC', 'nodeA.jump')\n            component.__.flow.clear('nodeA.jump') // Equivalent   \n        }\n    },\n\n    {\n        name: `component.run('nodeA.jump')`,\n        ignore: true,\n        function: () => {\n            component.nodeA.jump(); // should not trigger nodeC listener \n        }\n    },\n\n    {\n        header: `Resubscribe nodeB.nodeC from nodeA.jump`,\n        ignore: true,\n        function: () => {\n            component.__.flow.subscribe('nodeB.nodeC', 'nodeA.jump')\n        }\n    },\n\n    {\n        name: `component.run('nodeA.jump')`,\n        ignore: true,\n        function: () => {\n            component.nodeA.jump(); //same \n        }\n    },\n\n\n    // BACK TO WORKING STUFF\n    {\n        header: 'Create Second Component from First',\n        function: function () {\n            secondComponent = core.create({tree:{ component }}, undefined, options);\n            console.log('Got component 2', secondComponent)\n\n        }\n    },\n    {\n        header: 'Remove Node B',\n        function: function () {\n            popped = component.nodeB\n            component.nodeB.__parent = null\n\n            console.log(popped.__.path, 'popped')\n        }\n    },\n    {\n        name: `component.get('nodeA').jump()`,\n        function: () => {\n            component.nodeA.jump(); //should not trigger nodeC listener\n        }\n    },\n    {\n        header: 'Reparent Node B to Second Component',\n        ignore: false,\n        function: () => {\n            popped.__parent = secondComponent\n            console.log('Has Been Reparented', popped.__.root === secondComponent.__.root)\n        }\n    },\n    {\n        name: `popped.x += 1`,\n        function: () => {\n            popped.x += 1; //should no longer trigger nodeA.x listener on nodeC NOR the nodeB.x listener on nodeA\n        }\n    },\n    {\n        name: `popped.__children.nodeC.__operator(1)`,\n        function: () => {\n            popped.nodeC.default(1);\n        }\n    },\n    {\n        name: `component.get('nodeA').jump()`,\n        function: () => {\n            component.nodeA.jump(); //this should not trigger the nodeA.jump listener on nodeC now\n        }\n    },\n]", "// Benchmark Performance on Graph Construction\nexport const checkPerformance = async (callback, times = 1, cleanupCallback?) => {\n    const callbacks = Array.from({length: times}).map(() => callback)\n\n    const timesArr: number[] = []\n    let count = 0\n    for await (callback of callbacks) {\n        const start = performance.now()\n        const res = await callback(count)\n        const end = performance.now()\n        if (cleanupCallback) cleanupCallback(res)\n        const time = end - start\n        timesArr.push(time)\n        count++\n    }\n    return timesArr.reduce((acc, item) => acc + item, 0) / timesArr.length\n\n}", "import * as core from '../../packages/core/index'\nimport { model } from './index'\nimport { checkPerformance } from '../../packages/common/benchmark'\n\n\nconst nTimes = 1000\n\nconst checkInstantiationTime = async () => {\n    return checkPerformance(async (i) => {\n        const component = core.create(model)\n        await component.__resolved\n    }, nTimes).then(averageTime => {\n        console.log(`Time to Construct Graphs:`, averageTime)\n    }).then(() => {\n    \n    })\n}\n\n\nconst checkListenerTime = async () => {\n    const component = core.create(model)\n    return checkPerformance(async () => {\n        component.nodeA.jump();\n    }, nTimes).then(averageTime => {\n        console.log(`Time to Jump:`, averageTime)\n    })\n}\n\n\n// Run Benchmarks\ncheckInstantiationTime()\n.then(checkListenerTime)"],
  "mappings": "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",
  "names": []
}
