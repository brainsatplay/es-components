(()=>{var w=/([^,]*)/g;function N(b){var h=b.toString();let t=h.indexOf("("),n=h.indexOf(")"),o=(i,s=0)=>{let r=s+i.indexOf("{");return r<n&&r>t?o(i.slice(r),s+r):r},l=o(h),e;if(l===-1||n<l?e=h.slice(h.indexOf("(")+1,h.indexOf(")")):e=h.match(/([a-zA-Z]\w*|\([a-zA-Z]\w*(,\s*[a-zA-Z]\w*)*\)) =>/)?.[1],!e)return;let a=e.match(w).filter(i=>!!i),c=new Map;return a.forEach(i=>{let[s,r]=i.split("=");s=s.trim(),s=s.replace(/\d+$/,"");let f=s.includes("...");s=s.replace("...","");try{s&&c.set(s,{state:r&&(0,eval)(`(${r})`),spread:f})}catch{c.set(s,{}),console.warn(`Argument ${s} could not be parsed for`,b.toString(),r)}}),c}var O=N;var j="process"in globalThis,d=class{tag;graph;parent;element;parentNode;children={};tagName;style;attributes;#e=!1;#t;#s=new Promise(h=>this.#t=h);constructor(h,t={}){let n;Object.defineProperty(this,"parentNode",{get:()=>n,set:e=>{n=e,e?this.element&&(n.appendChild(this.element),typeof this.onrender=="function"&&this.onrender()):this.element&&this.element.remove()},enumerable:!0});let o;Object.defineProperty(this,"element",{get:()=>o,set:e=>{o=e,this.parentNode&&(this.parentNode.appendChild(e),typeof this.onrender=="function"&&this.onrender())},enumerable:!0}),this.tag=t.tag??"graph",Object.assign(this,h),this.parent=t.parent;let l=()=>t.parentNode??this.parent?.parentNode;if(this.parentNode=l(),this.graph)for(let e in this.graph.nodes){let a=this.graph.nodes[e];if(a instanceof d)a.tag=e,a.parent=this;else{let c=Object.assign({},Object.assign(t));this.graph.nodes[e]=new d(a,Object.assign(c,{tag:e,parent:this})),typeof t.onPlugin=="function"&&t.onPlugin(this.graph.nodes[e])}}if("default"in this&&t._arguments!==!1){let e=O(h.default)??new Map;e.size===0&&e.set("default",{});let a=e.keys().next().value;if(this.arguments)for(let i in this.arguments){let s=e.get(i);s.state=this.arguments[i],a===i&&(this.#e=!0)}this.arguments=e,this.graph={nodes:{},ports:{input:a,output:a}},Array.from(e.entries()).forEach(([i],s)=>{let r={default:async u=>{let m=e.get(i);return m.state=u,s===0?await this.run():u}},f=Object.assign({},Object.assign(t));this.graph.nodes[i]=new d(r,Object.assign(f,{tag:i,parent:this,_arguments:!1})),typeof t.onPlugin=="function"&&t.onPlugin(this.graph.nodes[i])});let c=this.default.bind(this);this.default=async(...i)=>{let s=[],r=0;return e.forEach((u,m)=>{let p=e.get(m),y=p.spread?i.slice(r):i[r],g=y!==void 0?y:u.state;p.state=g,p.spread||(g=[g]),s.push(...g),r++}),await c(...s)}}if(t.activate!==!1&&(typeof this.oncreate=="function"&&this.oncreate(),this.loop&&setInterval(()=>{this.run()},this.loop),!j)){if(this.tagName&&(this.element=document.createElement(this.tagName)),this.parentNode=l()??document.body,this.element&&this.attributes)for(let e in this.attributes){let a=this.attributes[e];if(typeof a=="function"){let c=a.bind(this);this.element[e]=i=>c(i)}else this.element[e]=a}}}init=async()=>{let h=this.parent,t=async(n,o)=>{let l=n.tag?o?`${n.tag}.${o}`:n.tag:o;if(n?.graph?.edges){let e=o.split("."),a=n;for(let i in e.slice(0,-1)){let s=e[i],r=n.graph.nodes[s]?.graph?.ports,f=Number.parseInt(i)+1;if(r?.output===e[f])a=n.graph.nodes[s];else{a=void 0;break}}let c=n.graph.edges[o]??n.graph.edges[l]??(a?n.graph.edges[e[0]]:void 0);for(let i in c){let s=n;i.split(".").forEach(r=>s=s.graph.nodes[r]),this.children[i]=s}}n.parent&&await t(n.parent,l)};h&&await t(h,this.tag),this.#t(!0),this.#e&&this.run()};run=async(...h)=>{let t={default:{},children:{}};if(await this.#s,!("default"in this)&&this.graph){let n=this.graph.ports?.input;if(n){let o=this.graph.ports?.output,l=this.graph.nodes[o].graph?.ports?`${o}.${this.graph.nodes[o].graph.ports.input}`:o,a=await this.graph.nodes[n].run(...h);t.children=Object.assign(t.children,a.children),t.default=(a.children[o]??a.children[l]).default}}else t.default=await this.default(...h);if(t.default!==void 0)for(let n in this.children){let o=Array.isArray(t.default)?t.default:[t.default],l=await this.children[n].run(...o);t.children[n]="default"in l?l.default:l;for(let e in l.children)t.children[e]=l.children[e]}return this.#e=!1,t}},x=d;})();
