{
  "version": 3,
  "sources": ["../src/graphscript/Graph.ts", "../src/graphscript/services/dom/DOMElement.js", "../src/graphscript/services/Service.ts", "../src/graphscript/services/dom/DOM.service.ts", "../src/transform.ts", "../src/parse.js", "../src/index.js"],
  "sourcesContent": ["export function parseFunctionFromText(method='') {\n    //Get the text inside of a function (regular or arrow);\n    let getFunctionBody = (methodString) => {\n        return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\n    }\n\n    let getFunctionHead = (methodString) => {\n        let startindex = methodString.indexOf('=>')+1;\n        if(startindex <= 0) {\n            startindex = methodString.indexOf('){');\n        }\n        if(startindex <= 0) {\n            startindex = methodString.indexOf(') {');\n        }\n        return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\n    }\n\n    let newFuncHead = getFunctionHead(method);\n    let newFuncBody = getFunctionBody(method);\n\n\n    let newFunc;\n    if (newFuncHead.includes('function')) {\n        let varName = newFuncHead.split('(')[1].split(')')[0]\n        newFunc = new Function(varName, newFuncBody);\n    } else {\n        if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\n        //newFuncBody = newFuncBody.substring(newFuncHead.length);\n        let varName = newFuncHead.split('(')[1].split(')')[0]\n        //console.log(varName, newFuncHead ,newFuncBody);\n        newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\n        }\n        else {\n        try {newFunc = (0,eval)(newFuncHead + newFuncBody + \"}\");} catch {}\n        }\n    }\n\n    return newFunc;\n\n}\n\n//just a more typical hierarchical graph tree with back and forward prop and arbitrary \n// go-here-do-that utilities. Create an object node tree and make it do... things \n// same setup as sequencer but object/array/tag only (no functions), and can add arbitrary properties to mutate on objects\n// or propagate to children/parents with utility calls that get added to the objects\n//Joshua Brewster and Garrett Flynn AGPLv3.0\n\nexport type OperatorType = ( //can be async\n    ...args:any //input arguments, e.g. output from another node\n)=>any|void\n\nexport type Tree = {\n    [key:string]: //the key becomes the node tag on the graph\n        GraphNode |\n        Graph | //for graphs, pass an input object to the operator like so: e.g. to run a node in the graph: node.run({run:[arg1,arg2]})\n        GraphNodeProperties |\n        OperatorType |\n        ((...args)=>any|void) |\n        { aliases:string[] } & GraphNodeProperties\n}\n\n//properties input on GraphNode or add, or for children\nexport type GraphNodeProperties = {\n    tag?:string, //generated if not specified, or use to get another node by tag instead of generating a new one\n    operator?:OperatorType|((...args)=>any|void), //Operator to handle I/O on this node. Returned inputs can propagate according to below settings\n    forward?:boolean, //pass output to child nodes\n    backward?:boolean, //pass output to parent node\n    children?:{[key:string]:string|boolean|undefined|GraphNodeProperties|GraphNode|Graph}//string|GraphNodeProperties|GraphNode|(GraphNodeProperties|GraphNode|string)[], //child node(s), can be tags of other nodes, properties objects like this, or GraphNodes, or null\n    parent?:GraphNode|Graph, //parent graph node\n    branch?:{ //based on the operator result, automatically do something\n        [label:string]:{ //apply any label for your own indexing\n            if:any|((output:any)=>boolean), //if this value, or pass a callback that returns true/false\n            then:string|((...operator_result:any[])=>any)|GraphNode //then do this, e.g. use a node tag, a GraphNode, or supply any function\n        } //it still returns afterward but is treated like an additional flow statement :D. GraphNodes being run will contain the origin node (who had the branch)\n    },\n    tree?:Tree, //can also declare independent node maps on a node for referencing\n    delay?:false|number, //ms delay to fire the node\n    repeat?:false|number, // set repeat as an integer to repeat the input n times, cmd will be the number of times the operation has been repeated\n    recursive?:false|number, //or set recursive with an integer to pass the output back in as the next input n times, cmd will be the number of times the operation has been repeated\n    frame?:boolean, //true or false. If repeating or recursing, execute on requestAnimationFrame? Careful mixing this with animate:true\n    animate?:boolean, //true or false, run the operation on an animationFrame loop?\n    loop?:false|number, //milliseconds or false, run the operation on a loop?\n    animation?: OperatorType, //if it outputs something not undefined it will trigger parent/child operators\n    looper?: OperatorType, //if it outputs something not undefined it will trigger parent/child operators\n    oncreate?:(self:GraphNode|any,...args:any[])=>void, //do something after _initializing the node, if loaded in a graph it only runs after setTree\n    ondelete?:(self:GraphNode|any,...args:any[])=>void, //do something after deleting the node\n    DEBUGNODE?:boolean, // print a console.time and the result for a node by tag, run DEBUGNODES on a GraphNode or Graph to toggle debug on all attached nodes.\n    [key:string]:any //add whatever variables and utilities\n}; //can specify properties of the element which can be subscribed to for changes.\n\n\n\n//TODO: try to reduce the async stack a bit for better optimization, though in general it is advantageous matter as long as node propagation isn't \n//   relied on for absolute maximal performance concerns, those generally require custom solutions e.g. matrix math or clever indexing, but this can be used as a step toward that.\n\n//a graph representing a callstack of nodes which can be arranged arbitrarily with forward and backprop or propagation to wherever\nexport const state = {\n    pushToState:{},\n    data:{},\n    triggers:{},\n    setState(updateObj:{[key:string]:any}){\n        Object.assign(state.data, updateObj);\n        for (const prop of Object.getOwnPropertyNames(updateObj)) {\n            if (state.triggers[prop]) state.triggers[prop].forEach((obj) => obj.onchange(state.data[prop]));\n        }\n        return state.data;\n    },\n    subscribeTrigger(key:string,onchange:(res:any)=>void){\n        if(key) {\n            if(!state.triggers[key]) {\n                state.triggers[key] = [];\n            }\n            let l = state.triggers[key].length;\n            state.triggers[key].push({idx:l, onchange});\n            return state.triggers[key].length-1;\n        } else return undefined;\n    },\n    unsubscribeTrigger(key:string,sub:number){\n        let idx = undefined;\n        let triggers = state.triggers[key]\n        if (triggers){\n            if(!sub) delete state.triggers[key];\n            else {\n                let obj = triggers.find((o)=>{\n                    if(o.idx===sub) {return true;}\n                });\n                if(obj) triggers.splice(idx,1);\n                return true;\n            }\n        }\n    },\n    subscribeTriggerOnce(key:string,onchange:(res:any)=>void) {\n        let sub;\n        \n        let changed = (value) => {\n            onchange(value);\n            state.unsubscribeTrigger(key,sub);\n        }\n        sub = state.subscribeTrigger(key,changed);\n    }\n}\n\n\n  /**\n   * Creates new instance of a GraphNode\n   * The methods of this class can be referenced in the operator after setup for more complex functionality\n   * \n   * ```typescript\n   * const graph = new GraphNode({custom: 1, operator: (input) => console.log(input, self.custom)});\n   * ```\n   */\n\nexport class GraphNode {\n\n    nodes:Map<any,any> = new Map()\n    _initial:{[key:string]:any} = {}; //keep track of custom _initial properties added that aren't default on the current class object\n\n    tag:string;\n    parent:GraphNode|Graph;\n    children:any;\n    graph:Graph;\n    state = state; //shared trigger state\n    isLooping = false;\n    isAnimating = false;\n    looper = undefined; //loop function, uses operator if undefined (with cmd 'loop');\n    animation = undefined; //animation function, uses operator if undefined (with cmd 'animate')\n    forward:boolean = true; /// propagate outputs to children?\n    backward:boolean = false; //propagate outputs to parents?\n    runSync:boolean = false;\n    firstRun:boolean = true;\n    DEBUGNODE:boolean = false; //prints a console.time and console.timeEnd on each runOp call\n    source:Graph|GraphNode; //if we pass a graph in as properties it will go here so as to not compete with the graphnode overlapping commands\n    tree:Tree;\n\n    [key:string]: any; // any additional attribute\n\n    constructor(\n        properties:GraphNodeProperties|Graph|OperatorType|((...args:any[])=>any|void)={}, \n        parentNode?:GraphNode|Graph, \n        graph?:Graph\n    ) {    \n\n        if(typeof properties === 'function') { //pass a function instead of properties to set up a functional graph quickly\n            properties = { operator:properties as any };\n        }\n\n        if(typeof properties === 'object') {\n\n            //can pass graphs and wrap Graphs with GraphNodes to enable nesting in trees\n            if(properties instanceof GraphNode && properties._initial) Object.assign(properties, properties._initial);\n            if(properties instanceof Graph) {\n                let source = properties;\n\n                properties = {\n                    source,\n                    operator:(input?:{[key:string]:any}) => {\n                        if(typeof input === 'object') {\n                            let result = {};\n                            for(const key in input) {\n                                if(typeof source[key] === 'function')\n                                    { //attempt to execute a function with arguments\n                                        if(Array.isArray(input[key]))\n                                            result[key] = (source[key](...input[key]));\n                                        else result[key] = source[key](input[key]);\n                                    } \n                                else {source[key] = input[key]; result[key] = source[key]}\n                            }\n                            return result;\n                        }\n                        return source;\n                    }\n                };\n\n                //in case any stuff was added to the graph to indicate flow logic\n                if(source.operator) properties.operator = source.operator;\n                if(source.children) properties.children = source.children;\n                if(source.forward) properties.forward = source.forward;\n                if(source.backward) properties.backward = source.backward;\n                if(source.repeat) properties.repeat = source.repeat;\n                if(source.recursive) properties.recursive = source.recursive;\n                if(source.loop) properties.loop = source.loop;\n                if(source.animate) properties.animate = source.animate;\n                if(source.looper) properties.looper = source.looper;\n                if(source.animation) properties.animation = source.animation;\n                if(source.delay) properties.delay = source.delay;\n                if(source.tag) properties.tag = source.tag;\n                if(source.oncreate) properties.oncreate = source.oncreate;\n                if(source.node) if(source.node._initial) Object.assign(properties,source.node._initial);\n                if(source._initial) Object.assign(properties,source._initial);\n\n                this.nodes = source.nodes;\n                source.node = this;\n                \n                if(graph) {\n                    source.nodes.forEach((n) => {\n                        if(!graph.nodes.get(n.tag)) {\n                            graph.nodes.set(n.tag,n);\n                            graph.nNodes++;\n                        }\n                    });\n                } //make sure node references get passed around correctly\n            }\n\n            if(properties.tag && (graph || parentNode)) {\n                let hasnode;\n                if(graph?.nodes) {\n                    hasnode = graph.nodes.get(properties.tag);\n                    // if(hasnode) if(hasnode.source instanceof Graph) { //duplicate the graph\n                    //     hasnode = new Graph(hasnode.source.tree,`${hasnode.tag}${graph.nNodes+1}`, properties);\n                    // }\n                }\n                if(!hasnode && parentNode?.nodes) {\n                    hasnode = parentNode.nodes.get(properties.tag);\n                    //if(hasnode) return hasnode; \n                } //return a different node if it already exists (implying we're chaining it in a flow graph using objects)\n                if(hasnode) {\n                    for (let k in hasnode)  this[k] = hasnode[k]; //set the node's props as this\n\n                    if(!this.source) this.source = hasnode;\n\n                    let props = hasnode.getProps();\n                    delete props.graph;\n                    delete props.parent;\n\n                    for (let k in props)  properties[k] = props[k];\n                }\n            }\n\n            if(properties?.operator) {\n                properties.operator = this.setOperator(properties.operator); //updates an arbitrary function if not fitting our operator format\n            }\n    \n            if(!properties.tag && graph) {\n                properties.tag = `node${graph.nNodes}`; //add a sequential id to find the node in the tree \n            }\n            else if(!properties.tag) {\n                properties.tag = `node${Math.floor(Math.random()*10000000000)}`; //add a random id for the top index if none supplied\n            }    \n\n            // for(const prop in properties) {\n            //     if(!(prop in this)) {\n            //         Object.defineProperty(this, prop,\n            //         {\n            //             enumerable : true, \n            //             configurable : true, \n            //             set: function(v) {\n            //                 this.firstRun = true; this[prop] = v; \n            //             } //reset firstrun if graph properties are changed so it can update flow logic potentially\n            //         });\n            //         this[prop] = properties[prop];\n            //     }\n            //     else this[prop] = properties[prop];\n            // }\n\n            let keys = Object.getOwnPropertyNames(this); \n            for(const key in properties) {\n                if(!keys.includes(key)) this._initial[key] = properties[key]; //get custom _initial values \n            }\n            if(properties.children) this._initial.children = Object.assign({},properties.children); //preserve the prototypes\n\n            for (let k in properties) this[k] = properties[k]; //set the node's props as this\n\n\n            if(!this.tag) {\n                if(graph) {\n                    this.tag = `node${graph.nNodes}`;\n                } else {\n                    this.tag = `node${Math.floor(Math.random()*10000000000)}`;\n                }\n            }      \n\n            if(graph) {\n                this.graph=graph;\n                if(graph.nodes.get(this.tag)) {\n                    this.tag = `${this.tag}${graph.nNodes+1}` //make sure the tags are unique\n                }\n                graph.nodes.set(this.tag,this);\n                graph.nNodes++;\n            }\n\n            if(parentNode) {\n                this.parent=parentNode;\n                if(parentNode instanceof GraphNode || parentNode instanceof Graph) parentNode.nodes.set(this.tag,this); //parentNode should get a mapped version with the original tag still\n            }\n            \n            if(typeof properties.tree === 'object') { //can generate node maps from trees in nodes that will be available for use in the main graph, and the main graph will index them by tag\n                for(const key in properties.tree) {\n                    if(typeof properties.tree[key] === 'object') if((!properties.tree[key] as any).tag) {\n                        (properties.tree[key] as any).tag = key;\n                    }\n                    let node = new GraphNode(properties.tree[key],this,graph);\n                    this.nodes.set(node.tag,node);\n                }\n            }\n        \n            if(this.children) this.convertChildrenToNodes(this);\n    \n            if(this.parent instanceof GraphNode || this.parent instanceof Graph) this.checkNodesHaveChildMapped(this.parent, this);\n        \n            if(typeof this.oncreate === 'function') this.oncreate(this);\n            if(!this.firstRun) this.firstRun = true; \n        }\n        else return properties;\n      \n    }\n    \n    // I/O scheme for this node in the graph\n    operator:OperatorType = (...args:any[]) => {\n        return args as any;\n    }\n    \n    //run the operator\n    runOp = (\n        ...args:any[]\n    ) => {\n        if(this.DEBUGNODE) console.time(this.tag);\n        let result = this.operator(...args);\n        if(result instanceof Promise) {\n            result.then((res) => {\n                if(res !== undefined) this.setState({[this.tag]:res}) //return null at minimum to setState\n                if(this.DEBUGNODE) {console.timeEnd(this.tag); if(result !== undefined) console.log(`${this.tag} result:`, result)};\n                return res;\n            })\n        }\n        else {\n            if(result !== undefined) this.setState({[this.tag]:result}); //return null at minimum to setState\n            if(this.DEBUGNODE) {console.timeEnd(this.tag); if(result !== undefined) console.log(`${this.tag} result:`, result)};\n        }\n        \n        return result;\n    }\n\n    //set an operator using our operator types or any arbitrary function :D    //this is the i/o handler, or the 'main' function for this node to propagate results. The origin is the node the data was propagated from \n    setOperator = (operator:OperatorType) => {\n        if(typeof operator !== 'function') return operator;\n        this.operator = operator.bind(this); // operator is always bound to this class instance\n        return operator;\n    }\n\n    /**\n     * Runs the graph node and passes output to connected nodes\n     *\n     * ```typescript\n     * const res = await node.run(arg1, arg2, arg3);\n     * ```\n     */   \n    \n    runAsync = (...args:any[]) => {\n        return new Promise((res,rej) => {res(this.run(...args))}); //will be a promise\n    }\n\n    transformArgs: (args:any[], self?:GraphNode) => any[] = (args=[]) => args\n\n    run = (...args:any[]) => {\n\n        if (typeof this.transformArgs === 'function') args = this.transformArgs(args, this)\n        \n        //console.log('running node ', node.tag, 'children: ', node.children);\n            \n        //can add an animationFrame coroutine, one per node //because why not\n        if(this.firstRun) {\n            this.firstRun = false;\n\n            if(\n                !( \n                   (this.children && this.forward) || \n                   (this.parent && this.backward) || \n                   this.repeat || this.delay || \n                   this.frame || this.recursive ||\n                   this.branch\n                )\n            ) this.runSync = true;\n\n            if(this.animate && !this.isAnimating) {\n                this.runAnimation(this.animation,args);\n            }\n\n            //can add an infinite loop coroutine, one per node, e.g. an internal subroutine\n            if(this.loop && typeof this.loop === 'number' && !this.isLooping) {\n                this.runLoop(this.looper,args);\n            }\n\n            if(this.loop || this.animate) return;\n\n        }\n    \n        //no async/flow logic so just run and return the operator result (which could still be a promise if the operator is async)\n        if(this.runSync){\n            let res = this.runOp(...args); //repeat/recurse before moving on to the parent/child\n            return res;\n        }\n\n        return new Promise(async (resolve) => {\n            if(this) {\n                let run = (node, tick=0, ...input):Promise<any> => {\n                    return new Promise (async (r) => {\n                        tick++;\n                        let res = await node.runOp(...input); //executes the operator on the node in the flow logic\n                        if(node.repeat) {\n                            while(tick < node.repeat) {\n                                if(node.delay) {\n                                    setTimeout(async ()=>{\n                                        r(await run(node,tick, ...input));\n                                    },node.delay);\n                                    break;\n                                } else if (node.frame && window?.requestAnimationFrame as any) {\n                                    requestAnimationFrame(async ()=>{\n                                        r(await run(node,tick, ...input));\n                                    });\n                                    break;\n                                }\n                                else res = await node.runOp(...input);\n                                tick++;\n                            }\n                            if(tick === node.repeat) {\n                                r(res);\n                                return;\n                            }\n                        } else if(node.recursive) {\n                            \n                            while(tick < node.recursive) {\n                                if(node.delay) {\n                                    setTimeout(async ()=>{\n                                        r(await run(node,tick, ...res));\n                                    },node.delay);\n                                    break;\n                                } else if (node.frame && window?.requestAnimationFrame as any) {\n                                    requestAnimationFrame(async ()=>{\n                                        r(await run(node,tick, ...res));\n                                    });\n                                    break;\n                                }\n                                else res = await node.runOp(...res);\n                                tick++;\n                            }\n                            if(tick === node.recursive) {\n                                r(res);\n                                return;\n                            }\n                        } else {\n                            r(res);\n                            return;\n                        }\n                    });\n                }\n    \n                let runnode = async () => {\n    \n                    let res = await run(this, undefined, ...args); //repeat/recurse before moving on to the parent/child\n    \n                    if(res !== undefined) { //if returning void let's not run the additional flow logic\n                        if(this.backward && this.parent instanceof GraphNode) {\n                            if(Array.isArray(res)) await this.runParent(this,...res);\n                            else await this.runParent(this,res);\n                        }\n                        if(this.children && this.forward) {\n                            if(Array.isArray(res)) await this.runChildren(this,...res);\n                            else await this.runChildren(this,res);\n                        }\n                        if(this.branch) {\n                            this.runBranch(this,res);\n                        }\n                    }\n    \n                    return res;\n                }\n    \n                if(this.delay) {\n                    setTimeout(async ()=>{\n                        resolve(await runnode());\n                    },this.delay);\n                } else if (this.frame && window?.requestAnimationFrame as any) {\n                    requestAnimationFrame(async ()=>{\n                        resolve(await runnode());\n                    });\n                } else {\n                    resolve(await runnode());\n                }\n                \n            }\n            else resolve(undefined);\n        });\n    }\n\n    runParent = async (n:GraphNode, ...args) => {\n        if(n.backward && n.parent) {\n            if(typeof n.parent === 'string') {\n                if(n.graph && n.graph?.get(n.parent)) {\n                    n.parent = n.graph;\n                    if(n.parent) this.nodes.set(n.parent.tag, n.parent);\n                }\n                else n.parent = this.nodes.get(n.parent);\n            }\n            \n            if(n.parent instanceof GraphNode) await n.parent.run(...args);\n        }\n    }\n\n    runChildren = async (n:GraphNode, ...args) => {\n\n        if(typeof n.children === 'object') {\n            for(const key in n.children) {\n                if (typeof n.children[key] === 'string') {\n                    if(n.graph && n.graph?.get(n.children[key])) {\n                        n.children[key] = n.graph.get(n.children[key]); //try graph scope\n                        if(!n.nodes.get(n.children[key].tag)) n.nodes.set(n.children[key].tag,n.children[key]);\n                    }\n                    if(!n.children[key] && n.nodes.get(n.children[key])) n.children[key] = n.nodes.get(n.children[key]); //try local scope\n                } else if (typeof n.children[key] === 'undefined' || n.children[key] === true) {\n                    if(n.graph && n.graph?.get(key)) {\n                        n.children[key] = n.graph.get(key); //try graph scope\n                        if(!n.nodes.get(n.children[key].tag)) n.nodes.set(n.children[key].tag,n.children[key]);\n                    }\n                    if(!n.children[key] && n.nodes.get(key)) n.children[key] = n.nodes.get(key); //try local scope\n                }\n                if(n.children[key]?.runOp)\n                    await n.children[key].run( ...args);\n            }\n        }\n    }\n\n    runBranch = async (n:GraphNode, output:any) => {\n        if(n.branch) {\n            let keys = Object.keys(n.branch);\n            await Promise.all(keys.map(async (k) => {\n                    if(typeof n.branch[k].if === 'object') n.branch[k].if = stringifyFast(n.branch[k].if); //stringify object outputs, stringifyFast saves a TON of overhead\n                    let pass = false;\n                    if(typeof n.branch[k].if === 'function') {\n                        pass = n.branch[k].if(output); //don't use async here, it's not a promise\n                    }\n                    else {\n                        if(typeof output === 'object') {if(stringifyFast(output) === n.branch[k].if) pass = true;}\n                        else if (output === n.branch[k].if) pass = true;\n                    }\n                    if(pass) {\n                        if(n.branch[k].then instanceof GraphNode) {\n                            if(Array.isArray(output))  await n.branch[k].then.run(...output);\n                            else await n.branch[k].then.run(...output);\n                        }\n                        else if (typeof n.branch[k].then === 'function') {\n                            if(Array.isArray(output)) await n.branch[k].then(...output)\n                            else await n.branch[k].then(output);\n                        } \n                        else if (typeof n.branch[k].then === 'string') {\n                            if(n.graph) n.branch[k].then = n.graph.nodes.get(n.branch[k].then);\n                            else n.branch[k].then = n.nodes.get(n.branch[k].then);\n\n                            if(n.branch[k].then instanceof GraphNode) {\n                                if(Array.isArray(output))  await n.branch[k].then.run(...output);\n                                else await n.branch[k].then.run(...output);\n                            } \n                        }\n                    }\n                    return pass;\n            }))\n        }\n    }\n    \n    runAnimation = (\n        animation:OperatorType=this.animation as any, \n        args:any[]=[], \n    ) => {\n        //can add an animationFrame coroutine, one per node //because why not\n        this.animation = animation as any;\n        if(!animation) this.animation = this.operator as any;\n        if(this.animate && !this.isAnimating && 'requestAnimationFrame' in window) {\n            this.isAnimating = true;\n            let anim = async () => {\n                //console.log('anim')\n                if(this.isAnimating) {\n                    if(this.DEBUGNODE) console.time(this.tag);\n                    let result = (this.animation  as any).call(this, ...args);\n                    if(result instanceof Promise) {\n                        result = await result;\n                    }\n                    if(this.DEBUGNODE) {console.timeEnd(this.tag); if(result !== undefined) console.log(`${this.tag} result:`, result)};\n                    if(result !== undefined) {\n                        if(this.tag) this.setState({[this.tag]:result}); //if the anim returns it can trigger state\n                        if(this.backward && this.parent?.run) {\n                            if(Array.isArray(result)) await this.runParent(this,...result);\n                            else await this.runParent(this,result);\n                        }\n                        if(this.children && this.forward) {\n                            if(Array.isArray(result)) await this.runChildren(this,...result);\n                            else await this.runChildren(this,result);\n                        }\n                        if(this.branch) {\n                            this.runBranch(this,result);\n                        }\n                        this.setState({[this.tag]:result});\n                    }\n                    requestAnimationFrame(anim);\n                }\n            }\n            requestAnimationFrame(anim);\n        }\n    }\n    \n    runLoop = (\n        loop:OperatorType=this.looper as any, \n        args:any[]=[], \n        timeout:number=this.loop\n    ) => {\n        //can add an infinite loop coroutine, one per node, e.g. an internal subroutine\n        this.looper = loop;\n        if(!loop) this.looper = this.operator;\n        if(typeof timeout === 'number' && !this.isLooping) {\n            this.isLooping = true;\n            let looping = async () => {\n                if(this.isLooping)  {\n                    if(this.DEBUGNODE) console.time(this.tag);\n                    let result = this.looper.call(this, ...args);\n                    if(result instanceof Promise) {\n                        result = await result;\n                    }\n                    if(this.DEBUGNODE) {console.timeEnd(this.tag); if(result !== undefined) console.log(`${this.tag} result:`, result)};\n                    if(result !== undefined) {\n                        if(this.tag) this.setState({[this.tag]:result}); //if the loop returns it can trigger state\n                        if(this.backward && this.parent?.run) {\n                            if(Array.isArray(result)) await this.runParent(this,...result);\n                            else await this.runParent(this,result);\n                        }\n                        if(this.children && this.forward) {\n                            if(Array.isArray(result)) await this.runChildren(this,...result);\n                            else await this.runChildren(this,result);\n                        }\n                        if(this.branch) {\n                            this.runBranch(this,result);\n                        }\n                        this.setState({[this.tag]:result});\n                    }\n                    setTimeout(async ()=>{ await looping(); }, timeout);\n                }\n            }\n            looping(); // -.-\n            //console.log('looping',timeout, loop, node.operator)\n        }\n    }\n    \n   \n    // Set GraphNode parent\n    setParent = (parent:GraphNode) => { \n        this.parent = parent;\n        if(this.backward) this.runSync = false;\n    }\n    \n    // Set GraphNode children\n    setChildren = (children:GraphNode|GraphNode[]) => {\n        this.children = children;\n        if(this.forward) this.runSync = false;\n    }\n    \n    //converts all children nodes and tag references to GraphNodes also\n    add = (n:GraphNodeProperties|OperatorType|((...args)=>any|void)={}) => {\n        if(typeof n === 'function') n = { operator:n as any};\n\n        if(!(n instanceof GraphNode)) n = new GraphNode(n,this,this.graph); \n        this.nodes.set(n.tag,n);\n        if(this.graph) {\n            this.graph.nodes.set(n.tag,n);\n            this.graph.nNodes = this.graph.nodes.size;\n        }\n        return n;\n    }\n    \n    remove = (n:string|GraphNode) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode) {\n            this.nodes.delete(n.tag);\n            if(this.children[n.tag]) delete this.children[n.tag];\n            if(this.graph) {\n                this.graph.nodes.delete(n.tag);\n                this.graph.nNodes = this.graph.nodes.size;\n            }\n            this.nodes.forEach((n:GraphNode) => {\n                if(n.nodes.get((n as GraphNode).tag)) {\n                    n.nodes.delete((n as GraphNode).tag);\n                    if(n.children[(n as GraphNode).tag]) delete n.children[(n as GraphNode).tag];\n                    if(n.parent?.tag === (n as GraphNode).tag) delete n.parent;\n                }\n            }); \n            \n            if(n.ondelete) n.ondelete(n);\n        }\n    }\n    \n    //append a node as a child to a parent node (this by default)\n    append = (n:string|GraphNode, parentNode=this) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode)  {\n            parentNode.addChildren(n);\n            if(n.forward) n.runSync = false;\n        }\n    }      \n            \n    //subscribe an output with an arbitrary callback\n    subscribe = (callback:GraphNode|((res)=>void),tag:string=this.tag) => {\n        if(callback instanceof GraphNode) {\n            return this.subscribeNode(callback);\n        } else return this.state.subscribeTrigger(tag,callback);\n    }\n    \n    //unsub the callback\n    unsubscribe = (sub:number,tag=this.tag) => {\n        this.state.unsubscribeTrigger(tag,sub);\n    }\n\n    //append child\n    addChildren = (children:{\n        [key:string]:string|boolean|undefined|GraphNode|Graph|GraphNodeProperties\n    }) => {\n        if(!this.children) this.children = {};\n        if(typeof children === 'object') {\n            Object.assign(this.children,children);\n        }\n        this.convertChildrenToNodes();\n        if(this.forward) this.runSync = false;\n    }\n\n    \n    //Call parent node operator directly (.run calls the flow logic)\n    callParent = (...args) => {\n        if(typeof this.parent === 'string') {\n            if(this.graph && this.graph?.get(this.parent)) {\n                this.parent = this.graph;\n                if(this.parent) this.nodes.set(this.parent.tag, this.parent);\n            }\n            else this.parent = this.nodes.get(this.parent);\n        }\n        if(typeof this.parent?.operator === 'function') return this.parent.runOp(...args);\n    }\n    \n    //call children operators directly (.run calls the flow logic)\n    callChildren = (...args) => {\n        let result;\n        if(typeof this.children === 'object') {\n            for(const key in this.children) {\n                if(this.children[key]?.runOp) this.children[key].runOp(...args);\n            }\n        }\n        return result;\n    }\n\n    getProps = (n=this) => {\n       return {\n         tag:n.tag,\n         operator:n.operator,\n         graph:n.graph,\n         children:n.children, //will return the original prototypes kept in this._initial if they exist\n         parent:n.parent,\n         forward:n.forward,\n         backward:n.bacward,\n         loop:n.loop,\n         animate:n.animate,\n         frame:n.frame,\n         delay:n.delay,\n         recursive:n.recursive,\n         repeat:n.repeat,\n         branch:n.branch,\n         oncreate:n.oncreate,\n         DEBUGNODE:n.DEBUGNODE,\n         ...this._initial\n       };\n    }\n    \n    setProps = (props:GraphNodeProperties={}) => {\n        let tmp = Object.assign({},props);\n        if(tmp.children) {\n            this.addChildren(props.children);\n            delete tmp.children;\n        }\n        if(tmp.operator) {\n            this.setOperator(props.operator);\n            delete tmp.operator;\n        }\n\n        Object.assign(tmp,props);\n        if(\n            !( \n               (this.children && this.forward) || \n               (this.parent && this.backward) || \n               this.repeat || this.delay || \n               this.frame || this.recursive\n            )\n        ) this.runSync = true;\n\n    }\n\n    removeTree = (n:GraphNode|string) => { //stop and dereference nodes to garbage collect them\n        if(n)if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode) {\n            let checked = {};\n            const recursivelyRemove = (node) => {\n                if(typeof node.children === 'object' && !checked[node.tag]) {\n                    checked[node.tag] = true;\n                    for(const key in node.children) {\n                        if(node.children[key].stopNode) \n                            node.children[key].stopNode();\n                        if(node.children[key].tag) {\n                            if(this.nodes.get(node.children[key].tag)) \n                                this.nodes.delete(node.children[key].tag);\n\n                            this.nodes.forEach((n) => {\n                                if(n.nodes.get(node.children[key].tag)) \n                                    n.nodes.delete(node.children[key].tag);\n                                if(n.children[key] instanceof GraphNode) \n                                    delete n.children[key];\n                            });\n                            recursivelyRemove(node.children[key]);\n                        }\n                    }\n                }\n            }\n            if(n.stopNode) \n                n.stopNode();\n            if(n.tag) {\n                this.nodes.delete(n.tag);\n                if(this.children[n.tag]) \n                    delete this.children[n.tag];\n                if(this.parent?.tag === n.tag) \n                    delete this.parent;\n                if(this[n.tag] instanceof GraphNode) \n                    delete this[n.tag];\n                this.nodes.forEach((n) => {\n                    if((n as GraphNode)?.tag) {\n                        if(n.nodes.get((n as GraphNode).tag)) n.nodes.delete((n as GraphNode).tag);\n                        if(n.children[(n as GraphNode).tag] instanceof GraphNode) \n                            delete n.children[(n as GraphNode).tag];\n                    }\n                });\n                recursivelyRemove(n);\n                if(this.graph) \n                    this.graph.removeTree(n, checked); //remove from parent graph too \n                else if(n.ondelete) \n                    n.ondelete(n);\n            }\n        }\n    }\n\n    checkNodesHaveChildMapped = (n:GraphNode|Graph, child:GraphNode, checked={}) => { //crawling around node/graph maps \n        let tag = n.tag;\n        if(!tag) tag = n.name;\n\n        if(!checked[tag]) {\n            checked[tag] = true;\n            if(n.children) {\n                if(child.tag in n.children) {\n                    if((n.children[child.tag] instanceof GraphNode)) {\n                        if(!n.nodes.get(child.tag)) n.nodes.set(child.tag,child);\n                        n.children[child.tag] = child;\n                        if(!n.firstRun) n.firstRun = true; \n                    }\n                }\n            }\n            if(n.parent instanceof GraphNode) {\n                if(n.nodes.get(child.tag) && !n.parent.nodes.get(child.tag)) \n                    n.parent.nodes.set(child.tag,child);\n                if(n.parent.children) {\n                    this.checkNodesHaveChildMapped(n.parent,child,checked);\n                } else if(n.nodes) {\n                    n.nodes.forEach((n) => {\n                        if(!checked[n.tag]) {\n                            this.checkNodesHaveChildMapped(n,child,checked);\n                        }\n                    });\n                }\n            } \n            if(n.graph) {\n                if(n.parent && (n.parent.name !== n.graph.name)) {\n                    n.graph.nodes.forEach((n) => {\n                        if(!checked[n.tag]) {\n                            this.checkNodesHaveChildMapped(n,child,checked);\n                        }\n                    });\n                }\n            }\n        }\n    }\n         \n    convertChildrenToNodes = (n:GraphNode=this) => {\n        if(n?.children) {\n            for(const key in n.children) { //object syntax instead of setting single nodes etc.\n                if(!(n.children[key] instanceof GraphNode)) {\n                    if (typeof n.children[key] === 'object') {\n                        if(!n.children[key].tag) n.children[key].tag = key;\n                        //console.log(key,n.tag,(n.graph.nodes.get(n.children[key].tag)?.parent.tag),n.graph.tag)\n                        if(!n.nodes.get(n.children[key].tag)) {\n                            //console.log(n.children[key], n.nodes.size);\n                            n.children[key] = new GraphNode(n.children[key],n,n.graph); //make a brand new graphnode based on the object spec\n                            this.checkNodesHaveChildMapped(n,n.children[key]); //then climb up the tree to make sure each enclosing layer has node references for these children\n                            //console.log(n.children[key], n.nodes.size);\n                        }\n                    }\n                    else {\n                        if(typeof n.children[key] === 'undefined' || n.children[key] == true) {\n                            n.children[key] = n.graph.get(key); //try graph scope\n                            if(!n.children[key]) n.children[key] = n.nodes.get(key);\n                        }\n                        else if(typeof n.children[key] === 'string') {\n                            let k = n.children[key];\n                            n.children[key] = n.graph.get(k); //try graph scope\n                            if(!n.children[key]) n.children[key] = n.nodes.get(key);\n                        } \n                        if(n.children[key] instanceof GraphNode) {\n                            if(n.graph) { //lets copy the node in this case so we have an independent instance we can parent properly\n                                let props = (n.children[key] as GraphNode).getProps(); //get the customized values of this node\n                                delete props.parent;\n                                delete props.graph;\n                                if(n.source instanceof Graph) {//map the node to a source graph if it a child of a graphnode that wraps a graph\n                                    n.children[key] = new GraphNode(props,n,(n as any).source); //make an new node instead of copying the old one.\n                                } else {\n                                    n.children[key] = new GraphNode(props,n,n.graph); //make an new node instead of copying the old one.\n                                }\n                            }\n                            n.nodes.set(n.children[key].tag, n.children[key]);\n                            this.checkNodesHaveChildMapped(n, n.children[key]); \n                            if(!(n.children[key].tag in n)) n[n.children[key].tag] = n.children[key]; //set it as a property by name too as an additional easy accessor; \n                        }\n                    }\n                }\n            }\n        }\n        return n.children;\n    }\n    \n    //stop any loops\n    stopLooping = (n:GraphNode=this) => {\n        n.isLooping = false;\n    }\n    \n    stopAnimating = (n:GraphNode=this) => {\n        n.isAnimating = false;\n    }\n    \n    stopNode = (n:GraphNode=this) => {\n        n.stopAnimating(n);\n        n.stopLooping(n);\n    }\n\n    \n    //subscribe a node (that isn't a forward-passed child of this node) to run after this node \n    subscribeNode = (n:GraphNode|string) => {\n        if(typeof n === 'string') n = this.nodes.get(n) as GraphNode;\n        if(n.tag) this.nodes.set(n.tag,n); //register the node on this node\n        if(n) return this.state.subscribeTrigger(this.tag,\n            (res)=>{\n                if(Array.isArray(res)) (n as GraphNode).run(...res);\n                else (n as GraphNode).run(res);\n            })\n    }\n    \n    //recursively print a snapshot reconstructible json hierarchy of the node and the children. \n    // Start at the top/_initially called nodes to print the whole hierarchy in one go\n    print = (n:string|GraphNode=this,printChildren=true,nodesPrinted:any[]=[]) => {\n    \n        let dummyNode = new GraphNode(); //test against this for adding props\n    \n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode) {\n            \n            nodesPrinted.push(n.tag);\n        \n            let jsonToPrint:any = {\n                tag:n.tag,\n                operator:n.operator.toString()\n            };\n        \n            if(n.parent) jsonToPrint.parent = n.parent.tag;\n            //step through the children\n            if(typeof n.children === 'object') {\n                for(const key in n.children) {\n                    if(typeof n.children[key] === 'string') return n.children[key];\n                    if(nodesPrinted.includes(n.children[key].tag)) return n.children[key].tag;   \n                    else if(!printChildren) {\n                        return n.children[key].tag;\n                    }\n                    else return n.children[key].print(n.children[key],printChildren,nodesPrinted);\n                }\n            }\n        \n            for(const prop in n) {\n                if(prop === 'parent' || prop === 'children') continue; //skip these as they are dealt with as special cases\n                if(typeof (dummyNode as any)[prop] === 'undefined') {\n                    if(typeof n[prop] === 'function') {\n                        jsonToPrint[prop] = n[prop].toString()\n                    } else if (typeof n[prop] === 'object') {\n                        jsonToPrint[prop] = (JSON as any).stringifyWithCircularRefs(n[prop]); //circular references won't work, nested nodes already printed elsewhere in the tree will be kept as their tags\n                    } \n                    else {\n                        jsonToPrint[prop] = n[prop];\n                    }\n                }\n            }\n        \n            return JSON.stringify(jsonToPrint);\n            \n        }\n        \n    }\n    \n    //reconstruct a node hierarchy (incl. stringified functions) into a GraphNode set\n    reconstruct = (json:string|{[x:string]: any}) => {\n        let parsed = reconstructObject(json);\n        if(parsed) return this.add(parsed);\n    }\n\n    setState = this.state.setState; //little simpler\n\n    DEBUGNODES = (debugging:boolean=true) => {\n        this.DEBUGNODE = debugging;\n        this.nodes.forEach((n:GraphNode) => {\n            if(debugging) n.DEBUGNODE = true;\n            else n.DEBUGNODE = false;\n        });\n    }\n}\n\n\n\n// Macro set for GraphNodes\nexport class Graph {\n\n    nNodes = 0\n    tag:string;\n    nodes:Map<any,any> = new Map();\n    state=state;\n    _initial:any;\n\n    //can create preset node trees on the graph\n    tree:Tree = {};\n\n    [key:string]:any;\n\n    constructor( tree?:Tree, tag?:string, props?:{[key:string]:any} ) {\n        this.tag = tag ? tag : `graph${Math.floor(Math.random()*100000000000)}`;\n\n        if(props) {\n            for (let k in props) this[k] = props[k]; //set other props like flow properties in a nested graph\n            this._initial = props;\n        }\n        if(tree || Object.keys(this.tree).length > 0) this.setTree(tree);\n    }\n\n    //converts all children nodes and tag references to GraphNodes also\n    add = (n:GraphNode|GraphNodeProperties|OperatorType|((...args)=>any|void)={}) => {\n        let props = n;\n        if(!(n instanceof GraphNode)) n = new GraphNode(props,this,this); \n        else {\n            this.nNodes = this.nodes.size;\n            if(n.tag) {\n                this.tree[n.tag] = props; //set the head node prototype in the tree object\n                this.nodes.set(n.tag,n);\n            }\n        }\n\n        return n;\n    }\n\n    setTree = (tree:Tree = this.tree) => {\n\n        if(!tree) return;\n\n        for(const node in tree) { //add any nodes not added yet, assuming we aren't overwriting the same tags to the tree.\n            const n = this.nodes.get(node)\n            if(!n) {\n\n                if(typeof tree[node] === 'function') {\n                    this.add({tag:node, operator:tree[node] as OperatorType|((...args)=>any|void)});\n                }\n                else if (typeof tree[node] === 'object' && !Array.isArray(tree[node])) {\n                    if(!(tree[node] as any).tag) (tree[node] as any).tag = node;\n                    let newNode = this.add(tree[node]);\n                    if((tree[node] as GraphNodeProperties).aliases) {\n                        (tree[node] as GraphNodeProperties).aliases.forEach((a) => {\n                            this.nodes.set(a,newNode); \n                        });\n                    }\n                } else {\n                    //we are trying to load something like a number or array in this case so lets make it a node that just returns the value\n                    this.add({tag:node,operator:(...args) => {return tree[node];}});\n                }\n            } else {\n                if (typeof tree[node] === 'function') {\n                    n.setOperator(tree[node]);\n                }\n                else if(typeof tree[node] === 'object') {\n                    if(tree[node] instanceof GraphNode) {\n                        this.add(tree[node]);\n                    } else if(tree[node] instanceof Graph) {\n                        //in case any stuff was added to the graph to indicate flow logic\n                        let source = tree[node] as any;\n                        let properties = {} as any;\n                        if(source.operator) properties.operator = source.operator;\n                        if(source.children) properties.children = source.children;\n                        if(source.forward) properties.forward = source.forward;\n                        if(source.backward) properties.backward = source.backward;\n                        if(source.repeat) properties.repeat = source.repeat;\n                        if(source.recursive) properties.recursive = source.recursive;\n                        if(source.loop) properties.loop = source.loop;\n                        if(source.animate) properties.animate = source.animate;\n                        if(source.looper) properties.looper = source.looper;\n                        if(source.animation) properties.animation = source.animation;\n                        if(source.delay) properties.delay = source.delay;\n                        if(source.tag) properties.tag = source.tag;\n                        if(source.oncreate) properties.oncreate = source.oncreate;\n                        if(source.node?._initial) Object.assign(properties,source.node._initial);\n\n                        properties.nodes = source.nodes;\n                        properties.source = source;\n                        n.setProps(properties);\n                    } else {\n                        n.setProps(tree[node]);\n                    }\n                }\n            }\n        }\n\n        this.nodes.forEach((node:GraphNode) => { //swap any child strings out for the proper nodes\n\n            if(typeof node.children === 'object') {\n                for(const key in node.children) {\n                    if(typeof node.children[key] === 'string') {\n                        if(this.nodes.get(node.children[key])) {\n                            node.children[key] = this.nodes.get(node.children[key]);\n                        }\n                    } else if (node.children[key] === true || typeof node.children[key] === 'undefined') {\n                        if(this.nodes.get(key)) {\n                            node.children[key] = this.nodes.get(key);\n                        }\n                    }\n                    if(node.children[key] instanceof GraphNode) {\n                        node.checkNodesHaveChildMapped(node,node.children[key]);\n                    }\n                }\n            }\n            \n            if(typeof node.parent === 'string') {\n                if(this.nodes.get(node.parent)) {\n                    node.parent = this.nodes.get(node.parent);\n                    node.nodes.set(node.parent.tag,node.parent);\n                }\n            }\n        });\n\n    }\n\n    get = (tag:string) => {\n        return this.nodes.get(tag);\n    }\n\n    set = (n:GraphNode) => {\n        return this.nodes.set(n.tag,n);\n    }\n\n    //Should create a sync version with no promises (will block but be faster)\n    run = (n:string|GraphNode,...args) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode)\n            return n.run(...args)\n        else return undefined;\n    }\n    \n    runAsync = (n:string|GraphNode,...args) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode)\n            return new Promise((res,rej) => {res((n as GraphNode).run(...args))})\n        else return new Promise((res,rej) => {res(undefined)});\n    }\n\n    removeTree = (n:string|GraphNode, checked?:any) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode) {\n            if(!checked) checked = {};\n            const recursivelyRemove = (node:GraphNode) => {\n                if(node.children && !checked[node.tag]) {\n                    checked[node.tag] = true;\n                    if(Array.isArray(node.children)) {\n                        node.children.forEach((c)=>{\n                            if(c.stopNode) c.stopNode();\n                            if(c.tag) {\n                                if(this.nodes.get(c.tag)) this.nodes.delete(c.tag);\n                            }\n                            this.nodes.forEach((n) => {\n                                if(n.nodes.get(c.tag)) n.nodes.delete(c.tag);\n                            });\n                            recursivelyRemove(c);\n                        })\n                    }\n                    else if(typeof node.children === 'object') {\n                        if(node.stopNode) node.stopNode();\n                        if(node.tag) {\n                            if(this.nodes.get(node.tag)) this.nodes.delete(node.tag);\n                        }\n                        this.nodes.forEach((n) => {\n                            if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\n                        });\n                        recursivelyRemove(node);\n                    }\n                }\n            }\n            if((n as GraphNode).stopNode) (n as GraphNode).stopNode();\n            if((n as GraphNode).tag) {\n                this.nodes.delete((n as GraphNode).tag);\n                this.nodes.forEach((n) => {\n                    if(n.nodes.get((n as GraphNode).tag)) n.nodes.delete((n as GraphNode).tag);\n                });\n                this.nNodes = this.nodes.size;\n                recursivelyRemove(n as GraphNode);\n            }\n            if(n.ondelete) n.ondelete(n);\n        }\n        return n;\n    }\n\n    remove = (n:string|GraphNode) => {\n        if(typeof n === 'string') n = this.nodes.get(n);\n        if(n instanceof GraphNode) {\n            (n as GraphNode).stopNode();\n            if((n as GraphNode)?.tag) {\n                if(this.nodes.get((n as GraphNode).tag)) \n                {\n                    this.nodes.delete((n as GraphNode).tag);\n                    //if(this.graph) this.graph.nodes.delete(node.tag);\n                    this.nodes.forEach((n) => {\n                        if(n.nodes.get((n as GraphNode).tag)) n.nodes.delete((n as GraphNode).tag);\n                    });\n                }\n            }\n            if(n.ondelete) n.ondelete(n);\n        }\n        return n;\n    }\n\n    append = (n:GraphNode, parentNode:GraphNode) => {\n        parentNode.addChildren(n);\n    }\n\n    callParent = async (n:GraphNode, ...args ) => {\n        if(n?.parent) {\n            return await n.callParent(...args);\n        }\n    }\n\n    callChildren = async (n:GraphNode, ...args) => {\n        if(n?.children) {\n            return await n.callChildren(...args);\n        }\n    }\n\n    subscribe = (\n        n:string|GraphNode,\n        callback:GraphNode|string|((res:any)=>void) //subscribe a callback or another node (pass a node or string in this case)\n    ) => {\n        if(!callback) return;\n        if(n instanceof GraphNode && typeof callback === 'function') {\n            return n.subscribe(callback);\n        }\n        else if(callback instanceof GraphNode || typeof callback === 'string')\n            return this.subscribeNode(n,callback)\n        else if(typeof n == 'string') {\n            return this.state.subscribeTrigger(n,callback);\n        }\n    }\n\n    unsubscribe = (tag:string,sub:number) => {\n        this.state.unsubscribeTrigger(tag,sub);\n    }\n\n    //subscribe a node to this node that isn't a child of this node\n    subscribeNode = (inputNode:string|GraphNode, outputNode:GraphNode|string) => {\n        let tag;\n        if((inputNode as GraphNode)?.tag) tag = (inputNode as GraphNode).tag;\n        else if (typeof inputNode === 'string') tag = inputNode;\n        if(typeof outputNode === 'string') outputNode = this.nodes.get(outputNode);\n        //console.log(outputNode, inputNode);\n        if(inputNode && outputNode) {\n            let sub = this.state.subscribeTrigger(tag,(res)=>{ \n                if(Array.isArray(res)) (outputNode as GraphNode).run(...res);\n                else (outputNode as GraphNode).run(res);\n            }); // TODO: Check if correct node\n            //console.log(this.state,tag);\n            return sub;\n        } \n    }\n\n    stopNode = (n:string|GraphNode) => {\n        if(typeof n === 'string') {\n            n = this.nodes.get(n);\n        }\n        if(n instanceof GraphNode) {\n            n.stopNode(); //just sets node.isAnimating and node.isLooping to false\n        }\n    }\n\n    print = (n:GraphNode|undefined=undefined,printChildren=true) => {\n        if(n instanceof GraphNode) return n.print(n,printChildren);\n        else {\n            let printed = `{`;\n            this.nodes.forEach((n) => { //print all nodes if none specified\n                printed+=`\\n\"${n.tag}:${n.print(n,printChildren)}\"`  \n            });\n            return printed;\n        }\n    }\n\n    //reconstruct a node hierarchy (incl. stringified functions) into a GraphNode set\n    reconstruct = (json:string|{[x:string]: any}) => {\n        let parsed = reconstructObject(json);\n        if(parsed) return this.add(parsed);\n    }\n\n    create = (operator:OperatorType,parentNode:GraphNode,props:GraphNodeProperties) => {\n        return createNode(operator,parentNode,props,this);\n    }\n\n    setState = this.state.setState;\n\n    DEBUGNODES = (debugging:boolean=true) => {\n        this.nodes.forEach((n:GraphNode) => {\n            if(debugging) n.DEBUGNODE = true;\n            else n.DEBUGNODE = false;\n        });\n    }\n\n}\n\n\n//macro\nexport function reconstructNode(json:string|{[x:string]: any},parentNode,graph) {\n    let reconstructed = reconstructObject(json);\n    if(reconstructed) return new GraphNode(reconstructed,parentNode,graph);\n    else return undefined;\n}\n\n// exports.Graph = Graph;\n// exports.GraphNode = GraphNode;\n\n//parse stringified object with stringified functions\nexport function reconstructObject(json:string|{[x:string]: any}='{}') {\n    try{\n\n        // Allow raw object\n        let parsed = (typeof json === 'string') ? JSON.parse(json) : json\n\n        const parseObj = (obj) => {\n            for(const prop in obj) {\n                if(typeof obj[prop] === 'string') {\n                    let funcParsed = parseFunctionFromText(obj[prop]);\n                    if(typeof funcParsed === 'function') {\n                        obj[prop] = funcParsed;\n                    }\n                } else if (typeof obj[prop] === 'object') {\n                    parseObj(obj[prop]);\n                }\n            }\n            return obj;\n        }\n\n        return parseObj(parsed);\n    } catch(err) {console.error(err); return undefined;}\n\n}\n\nexport const stringifyWithCircularRefs = (function() {\n    const refs = new Map();\n    const parents:any[] = [];\n    const path = [\"this\"];\n\n    function clear() {\n        refs.clear();\n        parents.length = 0;\n        path.length = 1;\n    }\n\n    function updateParents(key, value) {\n        var idx = parents.length - 1;\n        var prev = parents[idx];\n        if(typeof prev === 'object') {\n            if (prev[key] === value || idx === 0) {\n                path.push(key);\n                parents.push(value.pushed);\n            } else {\n                while (idx-- >= 0) {\n                    prev = parents[idx];\n                    if(typeof prev === 'object') {\n                        if (prev[key] === value) {\n                            idx += 2;\n                            parents.length = idx;\n                            path.length = idx;\n                            --idx;\n                            parents[idx] = value;\n                            path[idx] = key;\n                            break;\n                        }\n                    }\n                    idx--;\n                }\n            }\n        }\n    }\n\n    function checkCircular(key, value) {\n    if (value != null) {\n        if (typeof value === \"object\") {\n        if (key) { updateParents(key, value); }\n\n        let other = refs.get(value);\n        if (other) {\n            return '[Circular Reference]' + other;\n        } else {\n            refs.set(value, path.join('.'));\n        }\n        }\n    }\n    return value;\n    }\n\n    return function stringifyWithCircularRefs(obj, space?) {\n    try {\n        parents.push(obj);\n        return JSON.stringify(obj, checkCircular, space);\n    } finally {\n        clear();\n    }\n    }\n})();\n\nif((JSON as any).stringifyWithCircularRefs === undefined) {\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\n    (JSON as any).stringifyWithCircularRefs = stringifyWithCircularRefs;\n}\n\n//partial stringification for objects and removing circular references. This allows MUCH faster object equivalency comparison with three-tier depth checking\nexport const stringifyFast = (function() {\n    const refs = new Map();\n    const parents:any = [];\n    const path = [\"this\"];\n\n    function clear() {\n        refs.clear();\n        parents.length = 0;\n        path.length = 1;\n    }\n\n    function updateParents(key, value) {\n        var idx = parents.length - 1;\n        //console.log(idx, parents[idx])\n        if(parents[idx]){\n            var prev = parents[idx];\n            //console.log(value); \n            if(typeof prev === 'object') {\n                if (prev[key] === value || idx === 0) {\n                    path.push(key);\n                    parents.push(value.pushed);\n                } else {\n                    while (idx-- >= 0) {\n                        prev = parents[idx];\n                        if(typeof prev === 'object') {\n                            if (prev[key] === value) {\n                                idx += 2;\n                                parents.length = idx;\n                                path.length = idx;\n                                --idx;\n                                parents[idx] = value;\n                                path[idx] = key;\n                                break;\n                            }\n                        }\n                        idx++;\n                    }\n                }\n            }\n        }\n    }\n\n    function checkValues(key, value) {\n        let val;\n        if (value != null) {\n            if (typeof value === \"object\") {\n                //if (key) { updateParents(key, value); }\n                let c = value.constructor.name;\n                if (key && c === 'Object') {updateParents(key, value); }\n\n                let other = refs.get(value);\n                if (other) {\n                    return '[Circular Reference]' + other;\n                } else {\n                    refs.set(value, path.join('.'));\n                }\n                if(c === \"Array\") { //Cut arrays down to 100 samples for referencing\n                    if(value.length > 20) {\n                        val = value.slice(value.length-20);\n                    } else val = value;\n                   // refs.set(val, path.join('.'));\n                }  \n                else if (c.includes(\"Set\")) {\n                    val = Array.from(value)\n                }  \n                else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\n                    val = \"instanceof_\"+c;\n                }\n                else if (c === 'Object') {\n                    let obj = {};\n                    for(const prop in value) {\n                        if (value[prop] == null){\n                            obj[prop] = value[prop]; \n                        }\n                        else if(Array.isArray(value[prop])) { \n                            if(value[prop].length>20)\n                                obj[prop] = value[prop].slice(value[prop].length-20); \n                            else obj[prop] = value[prop];\n                        } //deal with arrays in nested objects (e.g. means, slices)\n                        else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\n                            obj[prop] = {};\n                            for(const p in value[prop]) {\n                                if(Array.isArray(value[prop][p])) {\n                                    if(value[prop][p].length>20)\n                                        obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \n                                    else obj[prop][p] = value[prop][p];\n                                }\n                                else { \n                                    if (value[prop][p] != null){\n                                        let con = value[prop][p].constructor.name;\n                                        if (con.includes(\"Set\")) {\n                                            obj[prop][p] = Array.from(value[prop][p])\n                                        } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\n                                            obj[prop][p] = \"instanceof_\"+con; //3-deep nested objects are cut off\n                                        }  else {\n                                            obj[prop][p] = value[prop][p]; \n                                        }\n                                    } else {\n                                        obj[prop][p] = value[prop][p]; \n                                    }\n                                }\n                            }\n                        }\n                        else { \n                            let con = value[prop].constructor.name;\n                            if (con.includes(\"Set\")) {\n                                obj[prop] = Array.from(value[prop])\n                            } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\n                                obj[prop] = \"instanceof_\"+con;\n                            } else {\n                                obj[prop] = value[prop]; \n                            }\n                        }\n                    }\n                    //console.log(obj, value)\n                    val = obj;\n                    //refs.set(val, path.join('.'));\n                }\n                else {\n                    val = value;\n                }\n            } else {\n                val = value;\n            }\n        }\n        //console.log(value, val)\n        return val;\n    }\n\n    return function stringifyFast(obj, space?) {\n        parents.push(obj);\n        let res = JSON.stringify(obj, checkValues, space);\n        clear();\n        return res;\n    }\n})();\n\nif((JSON as any).stringifyFast === undefined) {\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\n    (JSON as any).stringifyFast = stringifyFast;\n}\n\nexport function createNode(operator:OperatorType,parentNode:GraphNode,props:GraphNodeProperties,graph:Graph) {\n    if(typeof props === 'object') {\n        (props.operator as any) = operator;\n        return new GraphNode(props,parentNode,graph);\n    }\n    return new GraphNode({operator:operator},parentNode,graph);\n}\n", "//from 'fragelement' on npm by Joshua Brewster (AGPL v3.0)\nexport class DOMElement extends HTMLElement { \n\n    template = function(self=this, props){ //return a string or html node\n        return `<div> Custom Fragment Props: ${JSON.stringify(props)} </div>`\n    }; //override the default template string by extending the class, or use options.template if calling the base class\n    props = {};\n    useShadow = false; //can set to attach a shadow DOM instead (local styles)\n    styles; //can set a style sheet which will toggle the shadow dom by default\n  \n    // NOTE: Referencing this inside one of these events will give you the GraphNode\n    oncreate; //(self,props) => {}  fires on element creation (e.g. to set up logic)\n    onresize; //(self,props) => {} fires on window resize\n    ondelete; //(self,props) => {} fires after element is deleted\n    onchanged; //(props) => {} fires when props change\n    renderonchanged=false; //(self,props) => {} fires after rerendering on props change\n\n    FRAGMENT; STYLE;\n    attachedShadow = false;\n\n    obsAttributes=[\"props\",\"options\",\"onchanged\",\"onresize\",\"ondelete\",\"oncreate\",\"template\"]\n \n    get observedAttributes() {\n        return this.obsAttributes;\n    }\n\n    get obsAttributes() {\n        return this.obsAttributes;\n    }\n\n    set obsAttributes(att) {\n        if(typeof att === 'string') {\n            this.obsAttributes.push(att);\n        } else if (Array.isArray(att)) this.obsAttributes=att;\n    }\n\n    static get tag(){return this.name.toLowerCase()+'-'} //tagName, default 'classname-'. Set as a static variable for the internal addElement to reference\n\n    //add self or a specified class to the window which can be used via html like <custom-tag></custom-tag>\n    //will default be the classname with a '-' at the end if no tag supplied\n    static addElement(tag=this.tag,cls=this,extend=undefined) {\n        addCustomElement(cls,tag,extend);\n    }\n\n    attributeChangedCallback = (name, old, val) => {\n        if(name === 'onchanged') {\n            let onchanged = val;\n            if(typeof onchanged === 'string') onchanged = parseFunctionFromText(onchanged);\n            if(typeof onchanged === 'function') { \n                this.onchanged =  onchanged;\n                this.state.data.props = this.props;\n                this.state.unsubscribeTrigger('props'); //remove any previous subs\n                this.state.subscribeTrigger('props',this.onchanged);\n                let changed = new CustomEvent('changed', {detail: { props:this.props, self:this }});\n                this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\n            }\n        }\n        else if(name === 'onresize') {\n            let onresize = val;\n            if(typeof onresize === 'string')  onresize = parseFunctionFromText(onresize);\n            if(typeof onresize === 'function') {\n                if(this.ONRESIZE) {\n                    try { window.removeEventListener('resize',this.ONRESIZE); } catch(err) {}\n                }\n                this.ONRESIZE = (ev) => { this.onresize(this.props,this); } \n                this.onresize = onresize;\n                window.addEventListener('resize',this.ONRESIZE);\n            }\n        }\n        else if(name === 'ondelete') {\n            let ondelete = val;\n            if(typeof ondelete === 'string') ondelete = parseFunctionFromText(ondelete);\n            if(typeof ondelete === 'function') { \n                this.ondelete = () => {\n                    if(this.ONRESIZE) window.removeEventListener('resize',this.ONRESIZE);\n                    this.state.unsubscribeTrigger('props');\n                    if(ondelete) ondelete(this.props,this);\n                }\n            }\n        }\n        else if(name === 'oncreate') { \n            let oncreate = val;\n            if(typeof oncreate === 'string') oncreate = parseFunctionFromText(oncreate);\n            if(typeof oncreate === 'function') { \n                this.oncreate = oncreate;\n            }\n        }\n        else if(name === 'renderonchanged') {\n            let rpc = val;\n            if(typeof this.renderonchanged === 'number') this.unsubscribeTrigger(this.renderonchanged);\n            if(typeof rpc === 'string') rpc = parseFunctionFromText(rpc);\n            if(typeof rpc === 'function') {\n                this.renderonchanged = this.state.subscribeTrigger('props', (p)=>{this.render(p); rpc(this,p);}); //rerender then call the onchanged function if provided\n            }\n            else if(rpc != false) this.renderonchanged = this.state.subscribeTrigger('props',this.render); //just rerender automatically if set to true instead of a function\n        }\n        else if(name === 'props') { //update the props, fires any onchanged stuff\n            let newProps = val;\n            if(typeof newProps === 'string') newProps = JSON.parse(newProps);\n\n            Object.assign(this.props,newProps);\n            this.state.setState({props:this.props});\n        }\n        else if(name === 'template') { //change the html template\n\n            let template = val;\n\n            this.template = template; //function or string;\n            \n            //render the new template\n            this.render(this.props);\n            let created = new CustomEvent('created', {detail: { props:this.props }});\n            this.dispatchEvent(created);\n\n        }\n        else { //arbitrary attributes\n            let parsed = val;\n            if(name.includes('eval_')) { // e.g. <custom-  eval_loginput=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\n                name = name.split('_')\n                name.shift()\n                name = name.join();\n                parsed = parseFunctionFromText(val);  \n            }\n            else if (typeof val === 'string') {\n                try {\n                    parsed = JSON.parse(val)\n                } catch (err) {\n                    parsed = val;\n                }\n            }\n            this[name] = parsed; // set arbitrary props \n            if(name !== 'props' && this.props) this.props[name] = parsed; //reflect it in the props object (to set props via attributes more easily)\n            //this.props[name] = val; //set arbitrary props via attributes\n        }\n    }\n\n    connectedCallback() {\n\n        // set initial props\n        if(!this.props) this.props = {};\n        //debugger;\n        let newProps = this.getAttribute('props');\n        if(typeof newProps === 'string') newProps = JSON.parse(newProps);\n\n        Object.assign(this.props,newProps);\n\n        this.state.setState({props:this.props});\n\n        //Observe arbitrary attributes\n            //console.log(this,this.attributes)\n        Array.from(this.attributes).forEach((att) => {\n            let name = att.name;\n            //console.log(name,this.getAttribute(name),this[name])\n            //get/set/observe arbitrary attributes\n            let parsed = att.value;\n            if(name.includes('eval_') || name.includes('()')) { // e.g. <custom-  loginput()=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\n                if(name.includes('eval_')) name = name.split('_');\n                else if (name.includes('()')) name = name.substring(0,name.indexOf('('));\n                name.shift()\n                name = name.join();\n                parsed = parseFunctionFromText(att.value);  \n            }\n            else if (typeof att.value === 'string') {\n                try {\n                    parsed = JSON.parse(att.value)\n                } catch (err) {\n                    parsed = att.value;\n                }\n            }\n            if(!this[name]) {\n                Object.defineProperties(\n                    this, att, {\n                        value:parsed,\n                        writable:true,\n                        get() { return this[name]; },\n                        set(val) { this.setAttribute(name, val); }\n                    }\n                )\n            }\n            this[name] = parsed;\n            if(name !== 'props') this.props[name] = parsed; //set on props too (e.g. to more easily modify initial conditions without stringifying an object)\n            this.obsAttributes.push(name);\n            \n            //console.log(this.observedAttributes);\n        });\n\n        let resizeevent = new CustomEvent('resized', {detail: { props:this.props, self:this }});\n        let changed = new CustomEvent('changed', {detail: { props:this.props, self:this }});\n        let deleted = new CustomEvent('deleted', {detail: { props:this.props, self:this }});\n        let created = new CustomEvent('created', {detail: { props:this.props, self:this }});\n        //now we can add event listeners for our custom events\n\n        \n        // if(this.styles) {\n        //     this.useShadow = true;\n        // }\n\n        this.render(this.props);\n        this.dispatchEvent(created);\n\n        this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\n\n        if(typeof this.onresize === 'function') {\n            if(this.ONRESIZE) {\n                try { window.removeEventListener('resize',this.ONRESIZE); } catch(err) {}\n            }\n            this.ONRESIZE = (ev) => { this.onresize(this,this.props); this.dispatchEvent(resizeevent); } \n            window.addEventListener('resize',this.ONRESIZE);       \n        }\n\n        if(typeof this.ondelete === 'function') {\n            let ondelete = this.ondelete;\n            this.ondelete = (props=this.props) => {\n                if(this.ONRESIZE) window.removeEventListener('resize',this.ONRESIZE);\n                this.state.unsubscribeTrigger('props');\n                this.dispatchEvent(deleted);\n                ondelete(this,props);\n            }\n        }\n\n        if(typeof this.onchanged === 'function') {\n            this.state.data.props = this.props;\n            this.state.subscribeTrigger('props',this.onchanged);\n        }\n\n        if(this.renderonchanged) { //set to true or a function or a function string\n            let rpc = this.renderonchanged;\n            if(typeof this.renderonchanged === 'number') this.unsubscribeTrigger(this.renderonchanged);\n            if(typeof rpc === 'string') rpc = parseFunctionFromText(rpc);\n            if(typeof rpc === 'function') {\n                this.renderonchanged = this.state.subscribeTrigger('props', (p)=>{this.render(p); rpc(this,p);}); //rerender then call the onchanged function if provided\n            }\n            else if(rpc !== false) this.renderonchanged = this.state.subscribeTrigger('props',this.render); //just rerender\n        }\n\n\n    }\n\n    constructor() {\n        super();\n    }\n\n    delete = () => { //deletes self from the DOM\n        this.remove();\n        if(typeof this.ondelete === 'function') this.ondelete(this.props);\n    };\n\n    render = (props=this.props) => {\n\n        if(typeof this.template === 'function') this.templateResult = this.template(this, props); //can pass a function\n        else this.templateResult = this.template;\n\n        if(this.styles) this.templateResult = `<style>${this.styles}</style>${this.templateResult}`;\n        //this.innerHTML = this.templateResult;\n\n        const t = document.createElement('template');\n\n        if(typeof this.templateResult === 'string') t.innerHTML = this.templateResult;\n        else if(this.templateResult instanceof HTMLElement) {\n            if(this.templateResult.parentNode) {\n                this.templateResult.parentNode.removeChild(this.templateResult); //swap to the new component\n            }\n            t.appendChild(this.templateResult);\n        }\n\n        const fragment = t.content;\n\n        if(this.FRAGMENT) { //will reappend the fragment without reappending the whole node if already rendered once\n            if(this.useShadow) {\n                //this.removeChild(this.shadowRoot)\n                if(this.STYLE) this.shadowRoot.removeChild(this.STYLE);\n                this.shadowRoot.removeChild(this.FRAGMENT);\n            }   \n            else this.removeChild(this.FRAGMENT); \n        }\n        if(this.useShadow) {\n            if(!this.attachedShadow) {\n                this.attachShadow({mode:'open'}).innerHTML = '<slot></slot>';\n                this.attachedShadow = true;\n            }\n            if(this.styles) {\n                let style = document.createElement('style');\n                style.textContent = this.styles;\n                this.shadowRoot.prepend(style);\n                this.STYLE = style;\n            }\n\n            this.shadowRoot.prepend(fragment); //now you need to use the shadowRoot.querySelector etc.\n            this.FRAGMENT = this.shadowRoot.childNodes[0];\n            //this.prepend(this.shadowRoot)\n        }   \n        else {\n            this.prepend(fragment);\n            this.FRAGMENT = this.childNodes[0];\n        }\n        \n\n        let rendered = new CustomEvent('rendered', {detail: { props:this.props, self:this }});\n        this.dispatchEvent(rendered);\n        \n        if(this.oncreate) this.oncreate(this,props); //set scripted behaviors\n    }\n\n    state = {\n        pushToState:{},\n        data:{},\n        triggers:{},\n        setState(updateObj){\n            Object.assign(this.pushToState,updateObj);\n\n            if(Object.keys(this.triggers).length > 0) {\n                // Object.assign(this.data,this.pushToState);\n                for (const prop of Object.getOwnPropertyNames(this.triggers)) {\n                    if(this.pushToState[prop]) {\n                        this.data[prop] = this.pushToState[prop]\n                        delete this.pushToState[prop];\n                        this.triggers[prop].forEach((obj)=>{\n                            obj.onchanged(this.data[prop]);\n                        });\n                    }\n                }\n            }\n\n            return this.pushToState;\n        },\n        subscribeTrigger(key,onchanged=(res)=>{}){\n            if(key) {\n                if(!this.triggers[key]) {\n                    this.triggers[key] = [];\n                }\n                let l = this.triggers[key].length;\n                this.triggers[key].push({idx:l, onchanged:onchanged});\n                return this.triggers[key].length-1;\n            } else return undefined;\n        },\n        unsubscribeTrigger(key,sub){\n            let idx = undefined;\n            let triggers = this.triggers[key]\n            if (triggers){\n                if(!sub) delete this.triggers[key];\n                else {\n                    let obj = triggers.find((o)=>{\n                        if(o.idx===sub) {return true;}\n                    });\n                    if(obj) triggers.splice(idx,1);\n                    return true;\n                }\n            }\n        },\n        subscribeTriggerOnce(key=undefined,onchanged=(value)=>{}) {\n            let sub;\n            let changed = (value) => {\n                onchanged(value);\n                this.unsubscribeTrigger(key,sub);\n            }\n\n            sub = this.subscribeTrigger(key,changed);\n        }\n    }\n\n    get props() {\n        return this.props;\n    } \n\n    set props(newProps={}) {\n        this.setAttribute('props',newProps);\n    }\n\n    get template() {\n        return this.template;\n    } \n\n    set template(template) {\n        this.setAttribute('template',template);\n    }\n\n    get render() {\n        return this.render;\n    }\n\n    get delete() {\n        return this.delete;\n    }\n\n    get state() {\n        return this.state;\n    }\n\n    //past tense just so it can't conflict with onchange\n    get onchanged() {\n        return this.onchanged;\n    } \n\n    set onchanged(onchanged) {\n        this.setAttribute('onchanged',onchanged);\n    }\n\n    get styles() {\n        return this.styles\n    }\n\n    set styles(templateStr) {\n        \n        this.styles = templateStr;\n\n        if(this.querySelector('style')) { //get the top style \n            // if(!this.useShadow) {\n            //     this.useShadow = true;\n            //     this.render()\n            // } else \n            this.querySelector('style').innerHTML = templateStr;\n\n        } else {\n            //this.useShadow = true;\n            this.render();\n        }\n    }\n\n    get renderonchanged() {\n        return this.renderonchanged;\n    }\n\n    set renderonchanged(onchanged) {\n        this.setAttribute('renderonchanged',onchanged);\n    }\n \n    get onresize() {\n        return this.props;\n    } \n\n    set onresize(onresize) {\n        this.setAttribute('onresize',onresize);\n    }\n\n    get ondelete() {\n        return this.props;\n    } \n\n    set ondelete(ondelete) {\n        this.setAttribute('ondelete',ondelete);\n    }\n\n    get oncreate() {\n        return this.oncreate;\n    } \n\n    set oncreate(oncreate) {\n        this.setAttribute('oncreated',oncreate);\n    }\n}\n\n//extend the DOMElement class with an new name, this name determines the element name (always lower case in the html regardless of class name cases)\nexport function addCustomElement(cls, tag, extend=null) {\n    try {\n        if(extend) {\n            if(tag) window.customElements.define(tag, cls, {extends:extend});\n            else window.customElements.define(cls.name.toLowerCase()+'-',cls, {extends:extend});\n        }\n        else {\n            if(tag) window.customElements.define(tag, cls);\n            else window.customElements.define(cls.name.toLowerCase()+'-',cls);\n        }\n    }\n    catch(err) {\n\n    }\n}\n\nexport function randomId(tag='') {\n    return tag+Math.floor(Math.random()*1000000000000000);\n}\n\n// Proper DOM fragment implementation which also creates customElements you can use like <so></so>. High HTML5 performance via template fragments\nexport function parseFunctionFromText(method) {\n    //Get the text inside of a function (regular or arrow);\n    let getFunctionBody = (methodString) => {\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\n    }\n\n    let getFunctionHead = (methodString) => {\n    let startindex = methodString.indexOf(')');\n    return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\n    }\n\n    let newFuncHead = getFunctionHead(method);\n    let newFuncBody = getFunctionBody(method);\n\n    let newFunc;\n    try{\n        if (newFuncHead.includes('function')) {\n            let varName = newFuncHead.split('(')[1].split(')')[0]\n            newFunc = new Function(varName, newFuncBody);\n        } else {\n            if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\n                //newFuncBody = newFuncBody.substring(newFuncHead.length);\n                let varName = newFuncHead.split('(')[1].split(')')[0]\n                //console.log(varName, newFuncHead ,newFuncBody);\n                newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\n            }\n            else {\n                try {\n                    newFunc = (0,eval)(newFuncHead + newFuncBody + \"}\");\n                } catch(err) {\n                    newFunc = (0,eval)(method); //try just evaluating the method\n                }\n            }\n        }\n    }\n    catch (err) {}\n\n    return newFunc;\n\n}\n\n", "import { Graph, GraphNode, GraphNodeProperties, OperatorType, stringifyWithCircularRefs } from \"../Graph\";\n\n/**\n * \n * A service extends acyclic graph to enhance networking operations and aggregate for our microservices\n * \n */\n\nexport type RouteProp = { //these are just multiple methods you can call on a route/node tag kind of like http requests but really it applies to any function you want to add to a route object if you specify that method even beyond these http themed names :D\n    get?:((...args:any)=>any|void),\n    post?:OperatorType|((...args)=>any|void), \n    put?:(...args:any)=>any|void,\n    head?:(...args:any)=>any|void,\n    delete?:(...args:any)=>any|void,\n    patch?:(...args:any)=>any|void,\n    options?:(...args:any)=>any|void,\n    connect?:(...args:any)=>any|void,\n    trace?:(...args:any)=>any|void,\n    aliases?:string[] \n} & GraphNodeProperties\n\nexport type Class = { new(...args: any[]): any; };\n\nexport type Route = \n    GraphNode |\n    GraphNodeProperties |\n    Graph | Service |\n    OperatorType |\n    ((...args)=>any|void) |\n    { aliases?:string[] } & GraphNodeProperties |\n    RouteProp | Class | any\n\nexport type Routes = { //same as the tree in the base acyclic graph but adds aliases and RouteProps handling\n    [key:string]: Route\n}\n\nexport type ServiceMessage = {\n    route?:string,  //the function/node to execute\n    args?:any, //route args or data depending on what we're handling\n    method?:string, //can specify get, post, etc. on http requests or on multiplexed routes using the RouteProp format\n    node?:string|GraphNode, //alt tag for routes\n    [key:string]:any //it's an object so do whatever, any messages meant for web protocols need to be stringified or buffered\n}\n\nexport type ServiceOptions = {\n    routes?:Routes|Routes[], \n    name?:string, \n    props?:{[key:string]:any}, \n    loadDefaultRoutes?:boolean,\n    includeClassName?:boolean,\n    routeFormat?:string,\n    customRoutes?:{ //modify routes or execute other functions based on the route properties? e.g. addElement in DOMService\n        [key:string]:(route:Route, routeKey:string, routes:Routes)=>Route|any|void\n    },\n    customChildren?:{ //modify child routes in the tree based on parent conditions\n        [key:string]:(child:Route, childRouteKey:string, parent:Route, routes:Routes, checked:Routes)=>Route|any|void\n    },\n    [key:string]:any\n};\n\nexport type TypedArray =\n| Int8Array\n| Uint8Array\n| Uint8ClampedArray\n| Int16Array\n| Uint16Array\n| Int32Array\n| Uint32Array\n| Float32Array\n| Float64Array;\n\n\nexport class Service extends Graph {\n\n    //routes denote paths and properties callable across interfaces and inherited by parent services (adding the service name in the \n    // front of the route like 'http/createServer'.\n    routes:Routes={}\n    loadDefaultRoutes = false;\n    keepState:boolean = true; //routes that don't trigger the graph on receive can still set state\n    firstLoad = true;\n\n    constructor(options:ServiceOptions={}) {\n        super(undefined,options.name ? options.name : `service${Math.floor(Math.random()*100000000000000)}`,options.props);\n        if(options.name) this.name = options.name;\n        else options.name = this.tag;\n        \n        if('loadDefaultRoutes' in options) {\n            this.loadDefaultRoutes = options.loadDefaultRoutes;\n            this.routes = Object.assign(this.defaultRoutes,this.routes);\n        }\n        \n        if(options || Object.keys(this.routes).length > 0) this.init(options);\n    }\n\n    init = (options?:ServiceOptions) => {\n        if(options) options = Object.assign({},options);\n        else options = {};\n\n        if(options.customRoutes) Object.assign(options.customRoutes,this.customRoutes);\n        else options.customRoutes = this.customRoutes;\n        \n        if(options.customChildren) Object.assign(options.customChildren,this.customChildren);\n        else options.customChildren = this.customChildren;\n        \n        if(Array.isArray(options.routes)) {\n            options.routes.forEach((r) => {\n                this.load(\n                    r, \n                    options.includeClassName, \n                    options.routeFormat,\n                    options.customRoutes,\n                    options.customChildren\n                );\n            });\n        }\n        else if(options.routes || ((Object.keys(this.routes).length > 0 || this.loadDefaultRoutes) && this.firstLoad)) \n            this.load(\n                options.routes, \n                options.includeClassName, \n                options.routeFormat,\n                options.customRoutes,\n                options.customChildren\n            ); //now process the routes for the acyclic graph to load them as graph nodes :-D\n    }\n    \n    load = (\n        routes?:Service|Graph|Routes|{name:string,module:{[key:string]:any}}|any, \n        includeClassName:boolean=true, //enumerate routes with the service or class name so they are run as e.g. 'http/createServer' so services don't accidentally overlap\n        routeFormat:string='.',\n        customRoutes?:ServiceOptions[\"customRoutes\"],\n        customChildren?:ServiceOptions[\"customChildren\"]\n    ) => {    \n        if(!routes && !this.loadDefaultRoutes && (Object.keys(this.routes).length > 0 || this.firstLoad)) return;\n        if(this.firstLoad) this.firstLoad = false;\n\n        if(customRoutes) customRoutes = Object.assign(this.customRoutes,customRoutes);\n        else customRoutes = this.customRoutes;\n        if(customChildren) customChildren = Object.assign(this.customChildren,customChildren);\n\n        //console.log(routes, customRoutes)\n\n        //console.log(this.routes);\n        let service;\n        let allRoutes = {};\n        if(routes) {\n            if(!(routes instanceof Graph) && (routes as any)?.name) { //class prototype\n                if(routes.module) {\n                    let mod = routes;\n                    routes = {};\n                    Object.getOwnPropertyNames(routes.module).forEach((prop) => { //iterate through \n                        if(includeClassName) routes[mod.name+routeFormat+prop] = routes.module[prop];\n                        else routes[prop] =  routes.module[prop];\n                    });\n                } else if (typeof routes === 'function') { //it's a service prototype... probably\n                    service = new routes({loadDefaultRoutes:this.loadDefaultRoutes});\n                    service.load();\n                    routes = service.routes;\n                }\n            } //we can instantiate a class and load the routes. Routes should run just fine referencing the classes' internal data structures without those being garbage collected.\n            else if (routes instanceof Graph || routes.source instanceof Graph) { //class instance\n                service = routes;\n                routes = {};\n                let name;\n                if(includeClassName) {\n                    name = service.name;\n                    if(!name) {\n                        name = service.tag;\n                        service.name = name;\n                    }\n                    if(!name) {\n                        name = `graph${Math.floor(Math.random()*1000000000000000)}`;\n                        service.name = name; \n                        service.tag = name;\n                    }\n                } \n\n                if(service.customRoutes && !this.customRoutes) this.customRoutes = service.customRoutes;\n                else if (service.customRoutes && this.customRoutes) Object.assign(this.customRoutes,service.customRoutes);\n\n                if(service.customChildren && !this.customChildren) this.customChildren = service.customChildren;\n                else if (service.customChildren && this.customChildren) Object.assign(this.customChildren, service.customChildren);\n\n                service.nodes.forEach((node)=>{\n                    //if(includeClassName) routes[name+routeFormat+node.tag] = node;\n                    //else \n                    routes[node.tag] = node;\n                    \n                    let checked = {};\n                    let checkChildGraphNodes = (nd:GraphNode, par?:GraphNode) => {\n                        if(!checked[nd.tag] || (par && includeClassName && !checked[par?.tag+routeFormat+nd.tag])) {\n                            if(!par) checked[nd.tag] = true;\n                            else checked[par.tag+routeFormat+nd.tag] = true;\n\n                            if(nd instanceof Graph || nd.source instanceof Graph) {\n                                if(includeClassName) {\n                                    let nm = nd.name;\n                                    if(!nm) {\n                                        nm = nd.tag;\n                                        nd.name = nm;\n                                    }\n                                    if(!nm) {\n                                        nm = `graph${Math.floor(Math.random()*1000000000000000)}`;\n                                        nd.name = nm; \n                                        nd.tag = nm;\n                                    }\n                                } \n                                nd.nodes.forEach((n) => {\n                                    if(includeClassName && !routes[nd.tag+routeFormat+n.tag]) routes[nd.tag+routeFormat+n.tag] = n;\n                                    else if(!routes[n.tag]) routes[n.tag] = n; \n                                    checkChildGraphNodes(n,nd);\n                                });\n                            }\n                        }\n                    }\n\n                    checkChildGraphNodes(node);\n                });\n            }\n            else if (typeof routes === 'object') {\n                let name = routes.constructor.name;\n                if(name === 'Object') {\n                    name = Object.prototype.toString.call(routes);\n                    if(name) name = name.split(' ')[1];\n                    if(name) name = name.split(']')[0];\n                } \n                if(name && name !== 'Object') { \n                    let module = routes;\n                    routes = {};\n                    Object.getOwnPropertyNames(module).forEach((route) => {\n                        if(includeClassName) routes[name+routeFormat+route] = module[route];\n                        else routes[route] = module[route];\n                    });\n                }\n            }\n\n            if(service instanceof Graph && service.name && includeClassName) {     \n                //the routes provided from a service will add the route name in front of the route so like 'name/route' to minimize conflicts, \n                //incl making generic service routes accessible per service. The services are still independently usable while the loader \n                // service provides routes to the other services\n                routes = Object.assign({},routes); //copy props to a new object so we don't delete the original service routes\n                for(const prop in routes) { \n                    let route = routes[prop];\n                    delete routes[prop]; \n                    routes[service.name+routeFormat+prop] = route;  //store the routes in the loaded service under aliases including the service name\n                }\n            } \n\n        }\n\n        if(this.loadDefaultRoutes) {\n            let rts = Object.assign({},this.defaultRoutes); //load all default routes\n            if(routes) {\n                Object.assign(rts,this.routes); //then load declared routesin this object\n                routes = Object.assign(rts,routes); //then load new routes in constructor\n            } else routes = Object.assign(rts,this.routes); //then load declared routesin this object\n            \n            //console.log(this.name,this.routes,routes);\n            this.loadDefaultRoutes = false;\n        }\n\n        if(!routes) routes = this.routes;\n        \n        \n        let incr = 0;\n        for(const tag in routes) {\n            incr++;\n            let childrenIter = (route:RouteProp, routeKey:string) => {\n                if(typeof route === 'object') {\n                    if(!route.tag) route.tag = routeKey;\n                    if(typeof route?.children === 'object') {\n                        nested:\n                        for(const key in route.children) {\n                            incr++;\n                            if(typeof route.children[key] === 'object') {\n                                let rt = (route.children[key] as any);\n                            \n                                if(rt.tag && allRoutes[rt.tag]) continue;\n\n                                if(customChildren) {\n                                    for(const k in customChildren) {\n                                        rt = customChildren[k](rt,key,route,routes,allRoutes);\n                                        if(!rt) continue nested;\n                                    }\n                                }\n\n                                if(rt.id && !rt.tag) {\n                                    rt.tag = rt.id;\n                                } \n\n                                let k:any;\n                                if (rt.tag) {\n                                    if(allRoutes[rt.tag]) {\n                                        let randkey = `${rt.tag}${incr}`;\n                                        allRoutes[randkey] = rt; \n                                        rt.tag = randkey;\n                                        childrenIter(allRoutes[randkey],key)\n                                        k = randkey;\n                                    }\n                                    else {\n                                        allRoutes[rt.tag] = rt;\n                                        childrenIter(allRoutes[rt.tag],key)\n                                        k = rt.tag;\n                                    }\n                                } else {\n                                    if(allRoutes[key]) {\n                                        let randkey = `${key}${incr}`;\n                                        allRoutes[randkey] = rt; \n                                        rt.tag = randkey;\n                                        childrenIter(allRoutes[randkey],key)\n                                        k = randkey;\n                                    }\n                                    else {\n                                        allRoutes[key] = rt;\n                                        childrenIter(allRoutes[key],key)\n                                        k = key;\n                                    }\n                                }\n\n                                if(service?.name && includeClassName) {\n                                    allRoutes[service.name+routeFormat+k] = rt;\n                                    delete allRoutes[k];\n                                } else allRoutes[k] = rt;\n                            }\n                        }\n                    }\n                }\n            }\n            allRoutes[tag] = routes[tag]\n            childrenIter(routes[tag],tag);\n        }\n\n        //console.log(Object.keys(allRoutes))\n        top:\n        for(const route in allRoutes) { //modify all routes incl children\n            if(typeof allRoutes[route] === 'object') {\n                let r = allRoutes[route] as RouteProp;\n\n                if(typeof r === 'object') {\n\n                    if(customRoutes) { //mutate routes or run custom node creation functions\n                        for(const key in customRoutes) {\n                            r = customRoutes[key](r,route,allRoutes);\n                            if(!r) continue top; //nothing returned so continue\n                        }\n                    }\n \n                    if(r.get) { //maybe all of the http method mimics should get some shared extra specifications? \n                        if(typeof r.get == 'object') {\n                            \n                        }\n                    }\n                    if(r.post) {}\n                    if(r.delete) {}\n                    if(r.put) {}\n                    if(r.head) {}\n                    if(r.patch) {}\n                    if(r.options) {}\n                    if(r.connect) {}\n                    if(r.trace) {}\n\n                    //console.log('route', r)\n                    if(r.post && !r.operator) {\n                        allRoutes[route].operator = r.post;\n                    } else if (!r.operator && typeof r.get == 'function') {\n                        allRoutes[route].operator = r.get;\n                    }\n                }\n            }\n        }\n\n        for(const route in routes) {\n            if(typeof routes[route] === 'object') {\n                if(this.routes[route]) {\n                    if(typeof this.routes[route] === 'object') Object.assign(this.routes[route],routes[route]);\n                    else this.routes[route] = routes[route];\n                } else this.routes[route] = routes[route];\n            } else if(this.routes[route]) {\n                if(typeof this.routes[route] === 'object') Object.assign(this.routes[route],routes[route]);\n                else this.routes[route] = routes[route];\n            } else this.routes[route] = routes[route];\n        }\n\n        if(service) {\n            for(const key in this.routes) {\n                if(this.routes[key] instanceof GraphNode) {\n                    this.nodes.set(key,this.routes[key]);\n                    this.nNodes = this.nodes.size;\n                }\n            }\n        }\n        else this.setTree(this.routes);\n\n        for(const prop in this.routes) { //now set the aliases on the routes, the aliases share the same node otherwise\n            if((this.routes[prop] as any)?.aliases) {\n                let aliases = (this.routes[prop] as any).aliases;\n                aliases.forEach((a:string) => {\n                    if(service?.name && includeClassName) routes[service.name+routeFormat+a] = this.routes[prop]; //we're just gonna copy the routes to the aliases for simplicity \n                    else routes[a] = this.routes[prop];\n                });\n\n            }\n            \n        }\n\n        //console.log(this.name,this.routes);\n        return this.routes;\n    }\n\n    unload = (routes:Service|Routes|any=this.routes) => { //tries to delete the nodes along with the routes, incl stopping any looping nodes\n        if(!routes) return; \n        let service;\n        if(!(routes instanceof Service) && typeof routes === 'function') {\n            service = new Service();\n            routes = service.routes;\n        } //we can instantiate a class and load the routes. Routes should run just fine referencing the classes' internal data structures without those being garbage collected.\n        else if (routes instanceof Service) {\n            routes = routes.routes; //or pull routes from an existing class\n        }\n        for(const r in routes) {\n            delete this.routes[r]; //this is its own object separate from the node tree map\n            if(this.nodes.get(r)) this.remove(r);\n        }\n\n        return this.routes;\n    }\n\n    handleMethod = (\n        route:string, \n        method:string, \n        args?:any\n    ) => { //For handling RouteProp or other routes with multiple methods \n        let m = method.toLowerCase(); //lower case is enforced in the route keys\n        if(m === 'get' && ((this.routes[route] as RouteProp)?.get as any)?.transform instanceof Function) { //make alt formats for specific methods and execute them a certain way\n            if(Array.isArray(args)) return ((this.routes[route] as RouteProp).get as any).transform(...args);\n            else return ((this.routes[route] as RouteProp).get as any).transform(args);\n        }\n        if(this.routes[route]?.[m]) {\n            if(!(this.routes[route][m] instanceof Function)) {\n                if(args) this.routes[route][m] = args; //if args were passed set the value\n                return this.routes[route][m]; //could just be a stored local variable we are returning like a string or object\n            }\n            else return this.routes[route][m](args); \n            \n        }//these could be any function or property call\n        else return this.handleServiceMessage({route,args,method}) //process normally if the method doesn't return\n    }\n\n    handleServiceMessage(message:ServiceMessage) {\n        let call; \n        //console.log('message', message)\n        if(typeof message === 'object') {\n            if(message.route) call = message.route; else if (message.node) call = message.node;\n        }\n        if(call) {\n            //console.log('call',call,'message',message, 'nodes:', this.nodes.keys(),this)\n            if(Array.isArray(message.args)) return this.run(call,...message.args);\n            else return this.run(call,message.args);\n        } else return message;\n    }\n\n    handleGraphNodeCall(route:string|GraphNode, args:any) {\n        if(!route) return args;\n        if((args as ServiceMessage)?.args) {\n            this.handleServiceMessage(args);\n        }\n        else if(Array.isArray(args)) return this.run(route,...args);\n        else return this.run(route, args);\n    }\n\n    //transmit http requests, socket messages, webrtc, osc, etc. with this customizable callback\n    transmit:(...args)=>any|void = (\n        ...args:[ServiceMessage|any,...any[]]|any[]\n    ) => {\n        if(typeof args[0] === 'object') {\n            if(args[0].method) { //run a route method directly, results not linked to graph\n                return this.handleMethod(args[0].route, args[0].method, args[0].args);\n            } else if(args[0].route) {\n                return this.handleServiceMessage(args[0]);\n            } else if (args[0].node){\n                return this.handleGraphNodeCall(args[0].node, args[0].args);\n            } else if(this.keepState) {    \n                if(args[0].route)\n                    this.setState({[args[0].route]:args[0].args});\n                if(args[0].node)\n                    this.setState({[args[0].node]:args[0].args});\n            }\n            return args;\n        } else return args;\n    } \n\n    //process http requests, socket messages, webrtc, osc, etc. with this customizable callback. This default still works in some scenarios\n    receive:(...args)=>any|void = (\n        ...args:[ServiceMessage|any,...any[]]|any[] //generalized args for customizing, it looks weird I know\n    ) => {\n        if(args[0]) if(typeof args[0] === 'string') {\n            let substr = args[0].substring(0,8);\n            if(substr.includes('{') || substr.includes('[')) {    \n                if(substr.includes('\\\\')) args[0] = args[0].replace(/\\\\/g,\"\");\n                if(args[0][0] === '\"') { args[0] = args[0].substring(1,args[0].length-1)};\n                //console.log(args[0])\n                args[0] = JSON.parse(args[0]); //parse stringified args\n            }\n        }\n\n        if(typeof args[0] === 'object') {\n            if(args[0].method) { //run a route method directly, results not linked to graph\n                return this.handleMethod(args[0].route, args[0].method, args[0].args);\n            } else if(args[0].route) {\n                return this.handleServiceMessage(args[0]);\n            } else if (args[0].node){\n                return this.handleGraphNodeCall(args[0].node, args[0].args);\n            } else if(this.keepState) {    \n                if(args[0].route)\n                    this.setState({[args[0].route]:args[0].args});\n                if(args[0].node)\n                    this.setState({[args[0].node]:args[0].args});\n            } \n            return args;\n        } else return args;\n    }//these are fairly identical on the base template plus json parsing on the receive end\n\n    //we may want to auto pipe outputs from a node through our frontend<-->backend service protocol\n    pipe = (\n        source:GraphNode|string, \n        destination:string, \n        endpoint?:string|any, //the address or websocket etc. of the endpoint on the service we're using, this is different e.g. for sockets or http\n        method?:string, \n        callback?:(res:any)=>any|void\n    ) => {\n        if(source instanceof GraphNode) {\n            if(callback) return source.subscribe((res)=>{\n                let mod = callback(res); //either a modifier or a void function to do a thing before transmitting the data\n                if(mod !== undefined) this.transmit({route:destination, args:mod, method});\n                else this.transmit({route:destination, args:res, method}, endpoint);\n            })\n            else return this.subscribe(source,(res)=>{ this.transmit({route:destination, args:res, method}, endpoint); });\n        }\n        else if(typeof source === 'string') \n            return this.subscribe(source,(res)=>{ \n                this.transmit({route:destination, args:res, method}, endpoint); \n            });\n    }\n\n    //one-shot callback pipe e.g. to return results back through an endpoint\n    pipeOnce = (\n        source:GraphNode|string, \n        destination:string, \n        endpoint?:string|any, //the address or websocket etc. of the endpoint on the service we're using, this is different e.g. for sockets or http\n        method?:string, \n        callback?:(res:any)=>any|void\n    ) => {\n        if(source instanceof GraphNode) {\n            if(callback) return source.state.subscribeTriggerOnce(source.tag,(res)=>{\n                let mod = callback(res); //either a modifier or a void function to do a thing before transmitting the data\n                if(mod !== undefined) this.transmit({route:destination, args:mod, method});\n                else this.transmit({route:destination, args:res, method},endpoint);\n            })\n            else return this.state.subscribeTriggerOnce(source.tag,(res)=>{ \n                this.transmit({route:destination, args:res, method},endpoint); });\n        }\n        else if(typeof source === 'string') \n            return this.state.subscribeTriggerOnce(source,(res)=>{ \n                this.transmit({route:destination, args:res, method},endpoint); \n            });\n    }\n\n    terminate = (...args:any) => {\n       this.nodes.forEach((n) => {\n           n.stopNode(); //stops any loops\n       });\n    }\n    \n    isTypedArray(x:any) { //https://stackoverflow.com/a/40319428\n        return (ArrayBuffer.isView(x) && Object.prototype.toString.call(x) !== \"[object DataView]\");\n    }\n\n    recursivelyAssign = (target,obj) => {\n        for(const key in obj) {\n            if(typeof obj[key] === 'object') {\n                if(typeof target[key] === 'object') this.recursivelyAssign(target[key], obj[key]);\n                else target[key] = this.recursivelyAssign({},obj[key]); \n            } else target[key] = obj[key];\n        }\n\n        return target;\n    }\n    \n    //splice out a section of a typed array. If end is undefined we'll splice all values from the starting position to the end\n    //if you want to replace values, just use .set, this is for quickly removing values to trim arrays e.g. if an entity is popped\n    spliceTypedArray(arr:TypedArray,start:number,end?:number) {\n        let s = arr.subarray(0,start)\n        let e;\n        if(end) {\n            e = arr.subarray(end+1);\n        }\n\n        let n:TypedArray;\n        if(s.length > 0 || e?.length > 0) n = new (arr as any).constructor(s.length+e.length); //use the same constructor\n        if(s.length > 0) n.set(s);\n        if(e && e.length > 0) n.set(e,s.length);\n\n        return n;\n    }\n    \n    defaultRoutes:Routes = { //declared at the end so everything on this class is defined to pass through as node props\n        '/':{ //if no start page provided to HTTPbackend this will print instead on GET\n            get:()=>{ //if only a get or post are defined the will become the operator for making graph calls\n                return this.print();\n            },\n            aliases:['']\n        } as RouteProp,\n        ping:()=>{ //define functions, graph props, etc. All methods defined in a route object are callable\n            console.log('ping');//this.transmit('pong');\n            return 'pong';\n        },\n        echo:(...args:any)=>{ //this transmits input arguments, so to echo on a specific service do e.g. 'wss/echo'\n            this.transmit(...args);\n            return args;\n        },\n        assign:(source:{[key:string]:any}) => { //assign source to this\n            if(typeof source === 'object') \n            {Object.assign(this,source);\n            return true;} return false;\n        },\n        recursivelyAssign:(source:{[key:string]:any}) => { //assign source object to this\n            if(typeof source === 'object') \n            {this.recursivelyAssign(this,source);\n            return true;} return false;\n        },\n        log:{ //console.log/info\n            post:(...args:any)=>{\n                console.log(\"Log: \",...args);\n            },\n            aliases:['info']\n        } as RouteProp,\n        error:(message:string)=>{ //console.error\n            let er = new Error(message);\n            console.error(message);\n            return er;\n        },\n        state:(key?:string) => { //get state values\n            if(key) {\n                return this.state.data[key];\n            }\n            else return this.state.data;\n        },\n        printState:(key?:string) => {\n            if(key) {\n                return stringifyWithCircularRefs(this.state.data[key]);\n            } else return stringifyWithCircularRefs(this.state.data);\n        },\n        //bunch of methods generically available on routes for each service e.g. 'http/run' :-O\n        spliceTypedArray:this.spliceTypedArray,\n        transmit:this.transmit,\n        receive:this.receive,\n        load:this.load,\n        unload:this.unload,\n        pipe:this.pipe,\n        terminate:this.terminate,\n        run:this.run,\n        _run:this._run,\n        subscribe:this.subscribe,\n        subscribeNode:this.subscribeNode,\n        unsubscribe:this.unsubscribe,\n        stopNode:this.stopNode,\n        get:this.get,\n        add:this.add,\n        remove:this.remove,\n        setTree:this.setTree,\n        setState:this.setState,\n        print:this.print,\n        reconstruct:this.reconstruct,\n        handleMethod:this.handleMethod,\n        handleServiceMessage:this.handleServiceMessage,\n        handleGraphNodeCall:this.handleGraphNodeCall\n    }\n\n}", "import { DOMElement } from \"./DOMElement\"; //https://github.com/joshbrew/DOMElement <---- this is the special sauce\nimport { Graph, GraphNode, GraphNodeProperties, OperatorType } from '../../Graph';\nimport { RouteProp, Service, ServiceOptions } from \"../Service\";\n\nimport {CompleteOptions} from './types/general';\nimport { ElementInfo, ElementProps} from './types/element';\nimport { ComponentProps, ComponentInfo} from './types/component';\nimport {CanvasElementProps, CanvasOptions, CanvasElementInfo} from './types/canvascomponent';\n\n//alternative base service that additioanlly allows 'DOMRoutes' to be loaded which can tie in html and webcomponent blocks\n\n\nexport type DOMRouteProp = \n    ElementProps |\n    ComponentProps |\n    CanvasElementProps\n\nexport type DOMServiceRoute = \n    GraphNode |\n    GraphNodeProperties |\n    Graph |\n    OperatorType |\n    ((...args)=>any|void) |\n    { aliases?:string[] } & GraphNodeProperties |\n    RouteProp | \n    DOMRouteProp\n\n\nexport type DOMRoutes = {\n    [key:string]:DOMServiceRoute\n}\n\n\nexport class DOMService extends Service {\n\n    //routes denote paths and properties callable across interfaces and inherited by parent services (adding the service name in the \n    // front of the route like 'http/createServer'.\n    loadDefaultRoutes = false; //load default routes?\n    keepState:boolean = true; //routes that don't trigger the graph on receive can still set state\n    parentNode:HTMLElement=document.body; //default parent elements for elements added\n    name:string;\n    \n    interpreters = {\n        md:(template:string, options:ComponentProps) => { //https://unpkg.com/markdown-it@latest/dist/markdown-it.min.js \n            //@ts-ignore\n            if(typeof markdownit === 'undefined') { //this should synchronously load this script\n                document.head.insertAdjacentHTML('beforeend',`\n                    <script src='https://unpkg.com/markdown-it@latest/dist/markdown-it.min.js'></script>`\n                )\n            }\n\n            //@ts-ignore\n            let md = globalThis.markdownit(); //window.markdownit.parse() also\n            let html = md.render(template);\n        \n            options.template = html; // new template is the rendered markdown\n        },\n        jsx:(template:any, options:ComponentProps) => { //https://unpkg.com/react@latest/umd/react.production.min.js and https://unpkg.com/react-dom@latest/umd/react-dom.production.min.js\n            if(!options.parentNode) options.parentNode = this.parentNode;\n            if(typeof options.parentNode === 'string')  options.parentNode = document.getElementById( options.parentNode);\n\n            //@ts-ignore\n            if(typeof ReactDOM === 'undefined') {\n                document.head.insertAdjacentHTML('beforeend',`\n                    <script src='https://unpkg.com/react@latest/umd/react.production.min.js'></script>\n                    <script src='https://unpkg.com/react-dom@latest/umd/react-dom.production.min.js'></script>`\n                ); //get the necessary packages\n            }\n\n            options.template = '';\n\n            let onrender = options.onrender\n            options.onrender = (self: DOMElement, info?: ComponentInfo) => {\n                //@ts-ignore\n                const modal = ReactDOM.createPortal(template,options.id); //append the react modal to the new web component\n                onrender(self,info)\n            }\n            \n        }\n    }\n\n    customRoutes:ServiceOptions[\"customRoutes\"] = {\n        'dom':(r:DOMServiceRoute|any, route:string, routes:DOMRoutes|any) => {\n            // console.log(r)\n            if(r.template) { //assume its a component node\n                if(!r.tag) r.tag = route;\n                this.addComponent(r,r.generateChildElementNodes);\n            }\n            else if(r.context) { //assume its a canvas node\n                if(!r.tag) r.tag = route;\n                this.addCanvasComponent(r);\n            }\n            else if(r.tagName || r.element) { //assume its an element node\n                if(!r.tag) r.tag = route;\n                this.addElement(r,r.generateChildElementNodes);\n            }\n\n            return r;\n        }\n    }\n\n    customChildren:ServiceOptions[\"customChildren\"] = {\n        'dom':(rt:DOMServiceRoute|any, routeKey:string, route:any, routes:DOMRoutes, checked:DOMRoutes) => {\n            //automatically parent children html routes to parent html routes without needing explicit parentNode definitions\n            if((route.tag || route.id) && (route.template || route.context || route.tagName || route.element) && (rt.template || rt.context || rt.tagName || rt.element) && !rt.parentNode) {\n                if(route.tag) rt.parentNode = route.tag; \n                if(route.id) rt.parentNode = route.id;\n            }\n            return rt;\n        }\n    }\n\n    constructor(options?:ServiceOptions,parentNode?:HTMLElement,interpreters?:{[key:string]:(template:string,options:ComponentProps) => void}) {\n            super({props:options?.props,name:options?.name ? options.name : `dom${Math.floor(Math.random()*1000000000000000)}`});\n            \n            if(options?.parentNode) parentNode = options.parentNode;\n            if(typeof parentNode === 'string') parentNode = document.getElementById(parentNode);\n            if(parentNode instanceof HTMLElement) this.parentNode = parentNode;\n\n            if(interpreters) {\n                Object.assign(this.interpreters,interpreters);\n            }\n\n            this.init(options);\n            \n    }\n    \n    elements:{\n        [key:string]:ElementInfo\n    } = {}\n\n    components:{\n        [key:string]:ComponentInfo|CanvasElementInfo\n    } = {}\n\n    templates:{ //pass these in as options for quicker iteration\n        [key:string]:ComponentProps|CanvasElementProps\n    } = {}\n\n    resolveNode = (element, options) => {\n\n        let node: GraphNode\n        if(this.nodes.get(options.id)?.element?.parentNode?.id === options.parentNode || this.nodes.get(options.id)?.parentNode === options.parentNode) {\n            node = this.nodes.get(options.id);\n            node.element = element;\n        } else {\n            node = new GraphNode(\n                options,\n                options.parentNode ? this.nodes.get(options.parentNode) : this.parentNode,\n                this\n            );\n        }\n\n        // -------- Bind Functions to GraphNode --------\n        for (let key in options) if (typeof options[key] === 'function') options[key].bind(node)\n\n        return node\n    }\n\n    addElement=(\n        options: ElementProps,\n        generateChildElementNodes=false      \n    )=>{\n\n        let elm:HTMLElement = this.createElement(options)\n\n        let oncreate = options.onrender;\n\n        if(!options.element) options.element = elm;\n        if(!options.operator) options.operator = function (props:{[key:string]:any}){ \n            if(typeof props === 'object') \n                for(const key in props) { \n                    if(this.element) {\n                        if(typeof this.element[key] === 'function' && typeof props[key] !== 'function')\n                            { //attempt to execute a function with arguments\n                                if(Array.isArray(props[key]))\n                                this.element[key](...props[key]);\n                                else this.element[key](props[key]);\n                            } \n                        else if (key === 'style') { Object.assign(this.element[key],props[key])}\n                        else this.element[key] = props[key]; \n                    }\n                }\n                \n            return props;\n        }\n\n\n        let node = this.resolveNode(elm, options);\n        (elm as any).node = node; //self.node references the graphnode on the div now\n        \n        let divs:any[] = Array.from(elm.querySelectorAll('*'));\n        if(generateChildElementNodes) { //convert all child divs to additional nodes\n            divs = divs.map((d:HTMLElement,i) => this.addElement({element:d}));\n        }\n\n        this.elements[options.id] = {element:elm, node, parentNode: (options as CompleteOptions).parentNode, divs};\n        \n        if(!node.ondelete) node.ondelete = (node) => { \n            elm.remove(); \n            if(options.onremove) options.onremove(elm, this.elements[options.id]); \n        } //in this case we need to remove the element from the dom via the node and run callbacks here due to elements lacking an 'onremove' event\n\n        if(options.onresize) {\n            let onresize = options.onresize;\n            options.onresize = (ev) => { onresize(ev, elm, this.elements[options.id]) };\n            window.addEventListener('resize', options.onresize as EventListener);\n        }\n\n        \n        if(!elm.parentNode) {\n            setTimeout(()=>{ //slight delay on appendChild so the graph is up to date after other sync loading calls are finished\n                if(typeof options.parentNode === 'string') \n                    options.parentNode = document.getElementById(options.parentNode);\n                if(typeof options.parentNode === 'object') {\n                    // if(options.parentNode.shadowRoot) {\n                    //     console.log(options.parentNode.shadowRoot)\n                    //     options.parentNode.shadowRoot.appendChild(elm);\n                    // } else \n                    options.parentNode.appendChild(elm);\n                }\n\n                // // TODO: Figure out why newNode and node don't match...\n                // const newNode = this.nodes.get(node.tag)\n                // this.elements[options.id].node = newNode\n                // // console.log(node.tag, node, newNode, newNode === node)\n\n                if(oncreate) oncreate(elm,this.elements[options.id]);\n            },0.01);\n        }\n\n\n        return this.elements[options.id] as ElementInfo;\n    }\n\n    createElement = (options: ElementProps) => {\n\n        let elm: HTMLElement\n\n        if(options.element) {\n            if(typeof options.element === 'string') {\n                elm = document.querySelector(options.element); //get first element by tag or id \n                if(!elm) elm = document.getElementById(options.element); \n            }\n            else elm = options.element;\n        }\n        else if (options.tagName) elm = document.createElement(options.tagName);\n        else if(options.id && document.getElementById(options.id)) elm = document.getElementById(options.id);\n\n        if(!elm) return undefined;\n        this.updateOptions(options, elm);\n\n        return elm;\n    }\n\n    updateOptions = (options, element): CompleteOptions => {\n\n        if(!options.id && options.tag) options.id = options.tag;\n        if(!options.tag && options.id) options.tag = options.id;\n        if(!options.id) options.id = `${options.tagName ?? 'element'}${Math.floor(Math.random()*1000000000000000)}`;\n\n        if(typeof options.parentNode === 'string' && document.getElementById(options.parentNode)) \n            options.parentNode = document.getElementById(options.parentNode);\n        if(!options.parentNode) {        \n            if(!this.parentNode) this.parentNode = document.body;\n            options.parentNode = this.parentNode;\n        }\n       \n        element.id = options.id;\n        if(options.style) Object.assign(element.style,options.style);\n        if(options.attributes) Object.assign(element,options.attributes);\n        return options;\n    }\n\n    //create an element that is tied to a specific node, multiple elements can aggregate\n    // with the node\n    addComponent=(\n        options: ComponentProps,\n        generateChildElementNodes=true\n    )=>{\n        \n        if(options.onrender) {\n            let oncreate = options.onrender;\n            (options.onrender as any) = (self:DOMElement) => {\n                oncreate(self, options as ComponentInfo);\n            }\n        }\n        if(options.onresize) {\n            let onresize = options.onresize;\n            (options.onresize as any) = (self:DOMElement) => {\n                onresize(self, options as ComponentInfo);\n            }\n        }\n        if(options.onremove) {\n            let ondelete = options.onremove;\n            (options.onremove as any) = (self:DOMElement) => {\n                ondelete(self, options as ComponentInfo);\n            }\n        }\n        if(typeof options.renderonchanged === 'function') {\n            let renderonchanged = options.renderonchanged;\n            (options.renderonchanged as any) = (self:DOMElement) => {\n                renderonchanged(self, options as ComponentInfo);\n            }\n        }\n\n        if(options.interpreter && options.interpreter !== 'wc') {\n            this.interpreters[options.interpreter](options.template as string, options);\n        }\n\n        class CustomElement extends DOMElement {\n            props = options.props;\n            styles = options.styles;\n            useShadow = options.useShadow;\n            template = options.template as any;\n            oncreate = options.onrender;\n            onresize = options.onresize;\n            ondelete = options.onremove;\n            renderonchanged = options.renderonchanged as any;\n        }\n\n        if(!options.tagName) options.tagName = `custom-element${Math.random()*1000000000000000}`;\n\n        CustomElement.addElement(options.tagName); \n\n        let elm = document.createElement(options.tagName);\n        let completeOptions = this.updateOptions(options, elm) as ComponentProps\n        this.templates[completeOptions.id] = completeOptions;\n\n        let divs:any[] = Array.from(elm.querySelectorAll('*'));\n        if(generateChildElementNodes) { //convert all child divs to additional nodes\n            divs = divs.map((d:HTMLElement) => this.addElement({element:d}));\n        }\n\n        if(!options.element) options.element = elm;\n        if(!options.operator) options.operator = function op(props:{[key:string]:any}){ \n            if(typeof props === 'object') \n                for(const key in props) { \n                    if(this.element) {\n                        if(typeof this.element[key] === 'function' && typeof props[key] !== 'function')\n                            { //attempt to execute a function with arguments\n                                if(Array.isArray(props[key]))\n                                this.element[key](...props[key]);\n                                else this.element[key](props[key]);\n                            } \n                        else if (key === 'style') { Object.assign(this.element[key],props[key])}\n                        else this.element[key] = props[key]; \n                    }\n                }\n                \n            return props;\n        }\n\n        \n        let node = this.resolveNode(elm, options);\n\n        if(!node.ondelete) node.ondelete = (node) => { (elm as DOMElement).delete(); }\n\n        (elm as any).node = node; //this.node references the graphnode on the div now\n\n        this.components[completeOptions.id] = {\n            element:elm as any,\n            class:CustomElement,\n            node,\n            divs,\n            ...completeOptions\n        };\n\n                \n        if(!elm.parentNode) {\n            setTimeout(()=>{ //slight delay on appendChild so the graph is up to date after other sync tree/route loading calls are finished\n                if(typeof options.parentNode === 'string') options.parentNode = document.getElementById(options.parentNode);\n                if(typeof options.parentNode === 'object') {\n                    // if(options.parentNode.shadowRoot)\n                    //     options.parentNode.shadowRoot.appendChild(elm);\n                    // else \n                    options.parentNode.appendChild(elm);\n                }\n            },0.01);\n        }\n\n        return this.components[completeOptions.id] as ComponentInfo;\n    }\n\n    //create a canvas with a draw loop that can respond to props\n    addCanvasComponent=(\n        options: CanvasOptions\n    ) => {\n\n        if(!options.canvas) {\n            options.template = `<canvas `;\n            if(options.width) options.template += `width=\"${options.width}\"`;\n            if(options.height) options.template += `height=\"${options.height}\"`;\n            options.template+=` ></canvas>`;\n        } else options.template = options.canvas;\n                \n        if(options.onrender) {\n            let oncreate = options.onrender;\n            (options.onrender as any) = (self:DOMElement) => {\n                oncreate(self, options as any);\n            }\n        }\n        if(options.onresize) {\n            let onresize = options.onresize;\n            (options.onresize as any) = (self:DOMElement) => {\n                onresize(self, options as any);\n            }\n        }\n        if(options.ondelete) {\n            let ondelete = options.onremove;\n            (options.onremove as any) = (self:DOMElement) => {\n                ondelete(self, options as any);\n            }\n        }\n        if(typeof options.renderonchanged === 'function') {\n            let renderonchanged = options.renderonchanged;\n            (options.renderonchanged as any) = (self:DOMElement) => {\n                renderonchanged(self, options as any);\n            }\n        }\n\n        \n        class CustomElement extends DOMElement {\n            props = options.props;\n            styles = options.styles;\n            template = options.template;\n            oncreate = options.onrender;\n            onresize = options.onresize;\n            ondelete = options.onremove;\n            renderonchanged = options.renderonchanged as any;\n        }\n\n        if(!options.tagName) options.tagName = `custom-element${Math.random()*1000000000000000}`;\n\n        CustomElement.addElement(options.tagName);         \n        let elm = document.createElement(options.tagName);\n        const completeOptions = this.updateOptions(options, elm) as CanvasElementProps\n\n\n        let animation = () => { //default animation\n            if((this.components[completeOptions.id as string] as CanvasElementInfo)?.animating) {\n                (this.components[completeOptions.id as string] as CanvasElementInfo).draw(this.components[completeOptions.id as string].element,this.components[completeOptions.id as string] as CanvasElementInfo);\n                requestAnimationFrame(animation);\n            }\n        }\n\n        this.templates[completeOptions.id] = completeOptions;\n\n        if(!options.element) options.element = elm;\n        if(!options.operator) options.operator = function op(props:{[key:string]:any}){ \n            if(typeof props === 'object') \n                for(const key in props) { \n                    if(this.element) {\n                        if(typeof this.element[key] === 'function' && typeof props[key] !== 'function')\n                            { //attempt to execute a function with arguments\n                                if(Array.isArray(props[key]))\n                                this.element[key](...props[key]);\n                                else this.element[key](props[key]);\n                            } \n                        else if (key === 'style') { Object.assign(this.element[key],props[key])}\n                        else this.element[key] = props[key]; \n                    }\n                }\n                \n            return props;\n        }\n\n        let node = this.resolveNode(elm, options);\n        (elm as any).node = node; //self.node references the graphnode on the div now\n\n        if(!node.ondelete) node.ondelete = (node) => { (elm as DOMElement).delete(); }\n\n        let canvas = elm.querySelector('canvas');\n        if(completeOptions.style) Object.assign(canvas.style,completeOptions.style); //assign the style object\n\n        let context;\n        if(typeof completeOptions.context === 'object') context = options.context;\n        else if(typeof completeOptions.context === 'string') context = (canvas as HTMLCanvasElement).getContext(completeOptions.context);\n\n        this.components[completeOptions.id] = {\n            element:elm,\n            class:CustomElement,\n            template:completeOptions.template,\n            canvas,\n            node,\n            ...completeOptions\n        } as any;\n\n        (this.components[completeOptions.id] as CanvasElementInfo).context = context;\n\n        (elm as any).canvas = canvas; //make sure everything is accessible;\n        (elm as any).context = context; \n        node.canvas = canvas; //make sure everything is accessible;\n        node.context = context;\n      \n        if(!elm.parentNode) {\n            setTimeout(()=>{ //slight delay on appendChild so the graph is up to date after other sync tree/route loading calls are finished\n                if(typeof options.parentNode === 'string') options.parentNode = document.getElementById(options.parentNode);\n                if(typeof options.parentNode === 'object') {\n                    // if(options.parentNode.shadowRoot)\n                    //     options.parentNode.shadowRoot.appendChild(elm);\n                    // else \n                    options.parentNode.appendChild(elm);\n                }\n            },0.01);\n        }\n        \n        node.runAnimation(animation); //update the animation by calling this function again or setting node.animation manually\n\n        return this.components[completeOptions.id] as CanvasElementInfo;\n\n    }\n    \n    terminate = (element:string|DOMElement|HTMLElement|ComponentInfo|CanvasElementInfo)=>{\n        if(typeof element === 'object') {\n            if((element as CanvasElementInfo).animating)\n               (element as CanvasElementInfo).animating = false;\n\n            if((element as ComponentInfo|CanvasElementInfo).element) element = (element as ComponentInfo|CanvasElementInfo).element;\n         }\n        else if(typeof element === 'string' && this.components[element]) {\n            if((this.components[element] as CanvasElementInfo).node.isAnimating)\n                (this.components[element] as CanvasElementInfo).node.stopNode();\n            if((this.components[element] as ComponentInfo).divs)\n                (this.components[element] as ComponentInfo).divs.forEach((d) => this.terminate(d));\n                \n            let temp = this.components[element].element;\n            delete this.components[element]\n            element = temp;\n        }\n        else if(typeof element === 'string' && this.elements[element]) {\n            if(this.elements[element].divs)\n                this.elements[element].divs.forEach((d) => this.terminate(d));\n            let temp = this.elements[element].element;\n            if(this.elements[element].onresize) window.removeEventListener('resize',this.elements[element].onresize as EventListener);\n            if(this.elements[element].ondelete) this.elements[element].ondelete(temp,this.elements[element]);\n            delete this.elements[element];\n            element = temp;\n        }\n        \n        if(element) {\n            if(this.nodes.get((element as any).id)) {\n                this.removeTree((element as any).id);\n            }\n\n            if(element instanceof DOMElement)\n                element.delete(); //will trigger the ondelete callback\n            else if ((element as HTMLElement)?.parentNode) {\n                (element as any).parentNode.removeChild(element);\n            }\n\n            return true;\n        }\n        return false;\n    }\n    \n    defaultRoutes:DOMRoutes = { //declared at the end so everything on this class is defined to pass through as node props\n        addElement:this.addElement,\n        addComponent:this.addComponent,\n        addCanvasComponent:this.addCanvasComponent,\n        terminate:this.terminate\n    }\n\n}\n\n/**\n * Usage\n */\n\n// import {Router} from '../../routers/Router'\n\n// let router = new Router([\n//     DOMService\n// ]);\n\n// let elem = router.html.addElement(\n// {\n//     tagName:'div', //for an existing element, just pass the element object e.g. document.getElementById('testdiv')\n//     style:{backgroundColor:'black', width:'100px', height:'100px' },\n//     parentNode:document.body,\n//     id:'testdiv'\n// }\n// ); //this adds the element and creates a node that allows you to modify the HTMLElement properties or run functions e.g. click()\n\n// let node = elem.node;\n// let div = elem.element; //or node.element \n\n// setTimeout(()=>{\n//     node.run('testdiv',{style:{backgroundColor:'red'}}) //now we can modify properties on the element via node trees, function names can be called to pass an argument or array of arguments (wrap arrays in an array if its a single argument requiring an array)\n//     setTimeout(()=>{\n//         router.html.run('testdiv',{style:{backgroundColor:'black'}}) //equivalent call via the service stack\n//     },1000);\n// },1000);\n\n\n// let comp = router.html.addComponent({\n//     template:` \n//         <div>\n//             <button>Hello World!</button>\n//         </div>\n//     `, //or load an html file (if bundling)\n//     parentNode:document.body,\n//     styles:`\n//         div {\n//             background-color:black;\n//             width:100px;\n//             height:100px;\n//         }\n\n//         button {\n//             background-color: green;\n//             color: red;\n//         }\n//     `, //or load a css file (if bundling, scss also supported natively in esbuild)\n//     oncreate:(self:DOMElement,props:any) => { \n//         let button = self.querySelector('button');\n//         button.onclick = (ev) => { alert('Hello World!'); }\n//     }\n// });\n\n// let ccomp = router.html.addCanvasComponent({\n//     context:'2d',\n//     draw:(self:DOMElement,props:any)=>{\n//         let canvas = self.canvas as HTMLCanvasElement;\n//         let context = self.context as CanvasRenderingContext2D;\n\n//         context.clearRect(0,0,canvas.width,canvas.height);\n\n//         context.fillStyle = `rgb(0,0,${Math.sin(performance.now()*0.001)*255})`;\n//         context.fillRect(0,0,canvas.width,canvas.height);\n//     },\n//     width:'300px',\n//     height:'300px',\n//     style:{width:'300px', height:'300px'}\n// });", "import { Graph } from \"./graphscript/Graph\";\n\nexport default (tag, node) => {\n\n    const args = node.arguments as Map<string, any>\n\n    // Create Instance Argument Tree\n    const instanceTree = {};\n    Array.from(args.entries()).forEach(([arg], i) => {\n      instanceTree[arg] = {\n        tag: arg,\n        operator: (input) => {\n          const o = args.get(arg)\n          o.state = input\n          if (i === 0) return node.run();\n          return input;\n        }\n      };\n    });\n\n    // Create Proper Global Operator for the Instance\n    const originalOperator = node.operator.bind(node)\n    node.operator = (...argsArr) => {\n\n      let updatedArgs: any[] = [];\n      let i = 0;\n      args.forEach((o, k) => {\n        const argO = args.get(k)\n        const currentArg = argO.spread ? argsArr.slice(i) : argsArr[i];\n        let update = currentArg !== void 0 ? currentArg : o.state;\n        argO.state = update\n        if (!argO.spread)  update = [update];\n        updatedArgs.push(...update);\n        i++;\n      });\n\n\n        return originalOperator(...updatedArgs)\n    }\n\n    return new Graph(instanceTree, tag, node)\n  }", "// Fixed for bundled functions that may not have parentheses\nvar ARGUMENT_NAMES = /([^,]*)/g;\n\nexport function getFnParamInfo(fn) {\n    var fstr = fn.toString();\n    const openPar = fstr.indexOf(\"(\");\n    const closePar = fstr.indexOf(\")\");\n    const getFirstBracket = (str, offset = 0) => {\n      const fb = offset + str.indexOf(\"{\");\n      if (fb < closePar && fb > openPar) {\n        return getFirstBracket(str.slice(fb), offset + fb);\n      } else\n        return fb;\n    };\n    const firstBracket = getFirstBracket(fstr);\n    let innerMatch;\n    if (firstBracket === -1 || closePar < firstBracket)\n      innerMatch = fstr.slice(fstr.indexOf(\"(\") + 1, fstr.indexOf(\")\"));\n    else\n      innerMatch = fstr.match(/([a-zA-Z]\\w*|\\([a-zA-Z]\\w*(,\\s*[a-zA-Z]\\w*)*\\)) =>/)?.[1];\n\n    if(!innerMatch) \n        return undefined;\n\n    const matches = innerMatch.match(ARGUMENT_NAMES).filter((e) => !!e);\n\n    const info = new Map()\n    matches.forEach(v => {\n        let [name, value] = v.split('=')\n        name = name.trim()\n        name = name.replace(/\\d+$/, \"\"); // Account for bundling. RULE: No trailing numbers in argument names\n        const spread = name.includes('...')\n        name = name.replace(\"...\", \"\"); // Remove spread operator\n\n        try {\n            if (name) info.set(name,  {\n              state: (value) ? (0, eval)(`(${value})`) : value,\n              spread\n            })\n        } catch (e) {\n            info.set(name,  {})\n            console.warn(`Argument ${name} could not be parsed for`, fn.toString(), value);\n        }\n    })\n\n    return info\n}\n\nexport default getFnParamInfo", "import { GraphNode } from \"./graphscript/Graph\";\nimport { DOMService } from \"./graphscript/services/dom/DOM.service\";\n\nimport transform from \"./transform.js\";\nimport getFnParamInfo from \"./parse.js\";\n\nconst isNode = 'process' in globalThis\n\nclass ESPlugin {\n    \n    // Private\n    #initial;\n    #instance;\n    #graphscript;\n\n    get initial() { return this.#initial }\n\n    get instance() { return this.#instance }\n\n    get graphscript() { return this.#graphscript }\n    set graphscript(v) { this.#graphscript = v }\n\n    constructor(node, options = {}) {\n\n        // Get Base Initial Object\n        this.#initial = node;\n        do { this.#initial = this.initial.initial ?? this.initial } while (this.initial instanceof ESPlugin)\n        \n\n        // Parse Graphs\n        if (node.graph) {\n\n            // create graph tree\n            let tree = {}\n            for (let tag in this.initial.graph.nodes) {\n                const innerNode = this.initial.graph.nodes[tag]\n                tree[tag] = this.#create(tag, innerNode) // create new plugin (to be copied later)\n            }\n\n            const edges = this.initial.graph.edges\n            for (let output in edges) {\n                const outNode = tree[output]\n                if (!outNode.children) outNode.children = {}\n                for (let input in edges[output]) outNode.children[input] = true\n            }\n\n            this.graphscript = (isNode) ? new Graph(tree) : new DOMService({ routes: tree }, options.parentNode)\n\n            // Create ES Plugins Inside the Graph\n            for (let tag in this.initial.graph.nodes) {\n                const node = this.initial.graph.nodes[tag]\n                if (!(node instanceof ESPlugin)) {\n                    const clonedOptions = Object.assign({}, Object.assign(options))\n                    this.initial.graph.nodes[tag] = new ESPlugin(node, Object.assign(clonedOptions, { tag }))\n\n                    if (typeof options.onPlugin === 'function') options.onPlugin(node.graph.nodes[tag])\n                }\n\n                // Transfer Essential Info\n                else {\n                    const got = this.graphscript.nodes.get(tag)\n                    if (got) node.graphscript = got\n                }\n            }\n        }\n\n        // Parse ESPlugins (with default export)\n        if ('default' in this.initial) {\n            this.graphscript = new GraphNode(this.#create(options.tag ?? 'defaultESPluginTag', this.initial))    \n        }\n\n\n        let tag = this.graphscript?.tag\n        Object.defineProperty(this, 'tag', {\n            get: () => this.graphscript?.tag,\n            enumerable: true\n        })\n    }\n\n    #create = (tag, info) => {\n\n        let activeInfo;\n        if (info instanceof ESPlugin){\n            activeInfo = info.instance\n            info = info.initial\n        }\n\n        const args = getFnParamInfo(info.default) ?? new Map();\n        if (args.size === 0) args.set(\"default\", {});\n        const input = args.keys().next().value\n\n        // merge with user-specified arguments\n        if (info.arguments) {\n            for (let key in info.arguments) {\n                const o = args.get(key);\n                o.state = info.arguments[key];\n                if (input === key) this.run()  // run on initialization if setting the trigger\n            }\n        }\n\n        const gsIn = {\n            arguments: args,\n            operator: info.default,\n            tag\n        }\n\n\n        var props = Object.getOwnPropertyNames(info)\n        const onActive = ['arguments', 'default', 'tag', 'operator']\n        props.forEach(key => {\n            if (!onActive.includes(key)) gsIn[key] = info[key]\n        })\n\n        // Transfer Active Info \n        if (activeInfo) {\n            for (let key in activeInfo) {\n                if (!onActive.includes(key)) gsIn[key] = activeInfo[key] // replace with active\n            }\n        }\n\n        this.#instance = gsIn\n\n        return transform(tag, gsIn) // add arguments as sub-graphs\n    }\n\n    run = async (...args) => await this.graphscript.run(...args) // Call Graphscript by Proxy\n}\n\nexport default ESPlugin;\n"],
  "mappings": "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",
  "names": []
}
